/**
  @@@ START COPYRIGHT @@@

  (C) Copyright 2015 Hewlett-Packard Development Company, L.P.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  @@@ END COPYRIGHT @@@
*/


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <sql.h>
#include <sqlext.h>
#include <string.h>
#include "basedef.h"
#include "common.h"
#include "log.h"


#define NAME_LEN		300
#define MAX_C_TYPES		13
#ifdef UNICODE
#define MAX_NUM1		30
#define MAX_NUM2		19
#define MAX_NUM3		7
#define MAX_NUM4		20
#define	MAX_DATETIME	9
#define	MAX_TIMESTAMP	10
#else
#define MAX_NUM1		29
#define MAX_NUM2		16
#define MAX_NUM3		6
#define MAX_NUM4		19
#define	MAX_DATETIME	8
#define	MAX_TIMESTAMP	9
#endif

#define MAX_NUM5		13


PassFail TestMXSQLBindCol(TestInfo *pTestInfo)
{   
	TEST_DECLARE;
 	TCHAR			Heading[MAX_STRING_SIZE];
 	RETCODE			returncode;
 	SQLHANDLE 		henv;
 	SQLHANDLE 		hdbc;
 	SQLHANDLE		hstmt;
	int				loop_bindparam;
	TCHAR			*DrpTab1,*DrpTab2,*DrpTab3,*DrpTab4,*DrpTab5,*DrpTab6,*DrpTab7/*,*DrpTab8 */;
	TCHAR			*CrtTab1,*CrtTab2,*CrtTab3,*CrtTab4,*CrtTab5,*CrtTab6,*CrtTab7/*,*CrtTab8 */;
	TCHAR			*InsTab1,*InsTab2,*InsTab3,*InsTab4,*InsTab5,*InsTab6,*InsTab7/*,*InsTab8 */;
	TCHAR			*SelTab1,*SelTab2,*SelTab3,*SelTab4,*SelTab5,*SelTab6,*SelTab7/*,*SelTab8 */;

	TCHAR			*TestSQLTypeChar[] = {
											_T("SQL_CHAR"),    _T("SQL_VARCHAR"),          _T("SQL_DECIMAL"),    _T("SQL_NUMERIC"),
											_T("SQL_SMALLINT"),_T("SQL_SMALLINT UNSIGNED"),_T("SQL_INTEGER"),    _T("SQL_INTEGER UNSIGNED"),
											_T("SQL_REAL"),    _T("SQL_FLOAT"),            _T("SQL_DOUBLE"),     _T("SQL_DATE"),
											_T("SQL_TIME"),	   _T("SQL_TIMESTAMP"),		   _T("SQL_LONGVARCHAR"),_T("SQL_BIGINT"),
											_T("SQL_NUMERIC"), _T("SQL_NUMERIC"),          _T("SQL_NUMERIC"),    _T("SQL_NUMERIC"),
											_T("SQL_NUMERIC"), _T("SQL_NUMERIC"),		   _T("SQL_NUMERIC"),	 _T("SQL_NUMERIC"),
											_T("SQL_NUMERIC"), _T("SQL_NUMERIC"),          _T("SQL_WCHAR"),      _T("SQL_WVARCHAR"),
											_T("SQL_WLONGVARCHAR")
											#ifdef UNICODE
										     ,_T("SQL_WLONGVARCHAR")
										    #endif
										};
	TCHAR			*TestSQLTypeCharD[] = {
											_T("SQL_CHAR"),    _T("SQL_VARCHAR"),          	_T("SQL_DECIMAL"),    _T("SQL_NUMERIC"),
											_T("SQL_SMALLINT"),_T("SQL_SMALLINT UNSIGNED"),	_T("SQL_INTEGER"),    _T("SQL_INTEGER UNSIGNED"),
											_T("SQL_REAL"),    _T("SQL_FLOAT"),            	_T("SQL_DOUBLE"),     _T("SQL_DATE"),
											_T("SQL_TIME"),	   _T("SQL_TIMESTAMP"),		   	_T("SQL_LONGVARCHAR"),_T("SQL_BIGINT"),
											_T("SQL_WCHAR"),   _T("SQL_WVARCHAR"), 			_T("SQL_WLONGVARCHAR")
											#ifdef UNICODE
										     ,_T("SQL_WLONGVARCHAR")
										    #endif
										};
	
	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		TCHAR			*OutputValue[MAX_NUM1];
	} SQLDataValueTOC1[] = {// real, float and double precision to TCHAR has problem it returns 12345.0 values as 12345.
						{
							SQL_C_TCHAR,
							SQL_SUCCESS,
#ifndef _WM
							_T("--"), _T("--"), 
							_T("--"),_T("--"),_T("1"),_T("2"),_T("-3"),_T("4"),_T("-5"),_T("6"),_T("7"),_T("8"),_T("9"),_T("1997-01-02"),_T("03:04:05"),_T("1997-06-07 08:09:10"),_T(""),_T("10"),
							_T("0.123456789012345678"),
							_T("1234567890123456789"),
							_T("1234567890123.456789"),
							_T("0.1234567890123456789"),
							_T("1234567890123456789012345678901234567890123456789012345678901234"),
							_T("1234567890123456789012345678901234.012345678901234567890123456789"),
							_T("0.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("1234567890123456789012345678901234567890123456789012345678901234.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("0.12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345670"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#else
							_T("--"), _T("--"),
							_T("--"),_T("--"),_T("1"),_T("2"),_T("-3"),_T("4"),_T("-5"),_T("6"),_T("7"),_T("8"),_T("9"),_T("97/01/02"),_T("03:04:05"),_T("1997-06-07 08:09:10"),_T(""),_T("10"),
							_T(".123456789012345678"),
							_T("1234567890123456789"),
							_T("1234567890123.456789"),
							_T(".1234567890123456789"),
							_T("1234567890123456789012345678901234567890123456789012345678901234"),
							_T("1234567890123456789012345678901234.012345678901234567890123456789"),
							_T(".1234567890123456789012345678901234567890123456789012345678901234"),
							_T("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("1234567890123456789012345678901234567890123456789012345678901234.1234567890123456789012345678901234567890123456789012345678901234"),
							_T(".12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345670"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#endif
						},
						{
							SQL_C_TCHAR,
							SQL_SUCCESS,
#ifndef _WM
							_T("--"), _T("--"), 
							_T("--"),_T("--"),_T("20"),_T("56"),_T("-5471"),_T("6789"),_T("-56341"),_T("56789"),_T("-12340"),_T("-12300"),_T("-12345670"),_T("1993-12-30"),_T("11:45:23"),_T("1992-12-31 23:45:23.123456"),_T(""),_T("9876543"),
							_T("-0.123456789012345678"),
							_T("-1234567890123456789"),
							_T("-1234567890123.456789"),
							_T("-0.1234567890123456789"),
							_T("-1234567890123456789012345678901234567890123456789012345678901234"),
							_T("-1234567890123456789012345678901234.012345678901234567890123456789"),
							_T("-0.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("-12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("-1234567890123456789012345678901234567890123456789012345678901234.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("-0.12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345670"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#else
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("20"),_T("56"),_T("-5471"),_T("6789"),_T("-56341"),_T("56789"),_T("-12340"),_T("-12300"),_T("-12345670"),_T("93/12/30"),_T("11:45:23"),_T("1992-12-31 23:45:23.123456"),_T(""),_T("9876543"),
							_T("-.123456789012345678"),
							_T("-1234567890123456789"),
							_T("-1234567890123.456789"),
							_T("-.1234567890123456789"),
							_T("-1234567890123456789012345678901234567890123456789012345678901234"),
							_T("-1234567890123456789012345678901234.012345678901234567890123456789"),
							_T("-.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("-12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("-1234567890123456789012345678901234567890123456789012345678901234.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("-.12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345670"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#endif
						},
						{
							SQL_C_TCHAR,
							SQL_SUCCESS,
#ifndef _WM
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("987.65"),_T("543.12"),_T("-987"),_T("654"),_T("-98765"),_T("65432"),_T("9876.543"),_T("345678.543"),_T("456789.543"),_T("1997-01-02"),_T("03:04:05"),_T("1997-06-07 08:09:10"),_T(""),_T("9876543"),
							_T("-0.123456789000000000"),
							_T("1234567890"),
							_T("-123456789.456700"),
							_T("0.1234567890123450000"),
							_T("-123456789012345678901234567890"),
							_T("1234567890123456789.012345678901234567890000000000"),
							_T("-0.1234567890123456789012345678901234567890123456789000000000000000"),
							_T("12345678901234567890123456789012345678901234567890"),
							_T("-123456789012345678901234567890.1234567890123456789012340000000000000000000000000000000000000000"),
							_T("0.01234567890123456789012345678901234567890123456789012345678901234567800000000000000000000000000000000000000000000000000000000000"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#else
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("987.65"),_T("543.12"),_T("-987"),_T("654"),_T("-98765"),_T("65432"),_T("9876.543"),_T("345678.543"),_T("456789.543"),_T("97/01/02"),_T("03:04:05"),_T("1997-06-07 08:09:10"),_T(""),_T("9876543"),
							_T("-.123456789000000000"),
							_T("1234567890"),
							_T("-123456789.456700"),
							_T(".1234567890123450000"),
							_T("-123456789012345678901234567890"),
							_T("1234567890123456789.012345678901234567890000000000"),
							_T("-.1234567890123456789012345678901234567890123456789000000000000000"),
							_T("12345678901234567890123456789012345678901234567890"),
							_T("-123456789012345678901234567890.1234567890123456789012340000000000000000000000000000000000000000"),
							_T(".01234567890123456789012345678901234567890123456789012345678901234567800000000000000000000000000000000000000000000000000000000000"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#endif
						},
						{
							SQL_C_TCHAR,
							SQL_SUCCESS,
#ifndef _WM
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("1234.56789"),_T("5678.12345"),_T("-1234"),_T("6789"),_T("-12345"),_T("56789"),_T("12340"),_T("12300"),_T("12345670"),_T("1993-12-30"),_T("11:45:23"),_T("1992-12-31 23:45:23.123456"),_T(""),_T("-9876543"),
							_T("0.123456789"),
							_T("1234567890"),
							_T("12345.67899"),
							_T("0.1234567809"),
							_T("123456789012345678"),
							_T("123456789.123456789"),
							_T("0.123456789012345678"),
							_T("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("1234567890123456789012345678901234567890123456789012345678901234.1234567890123456789012345678901234567890123456789012345678901234"),
							_T("0.12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345670"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#else
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("1234.56789"),_T("5678.12345"),_T("-1234"),_T("6789"),_T("-12345"),_T("56789"),_T("12340"),_T("12300"),_T("12345670"),_T("93/12/30"),_T("11:45:23"),_T("1992-12-31 23:45:23.123456"),_T(""),_T("-9876543"),
							_T(".123456789"),
							_T("1234567890"),
							_T("12345.67899"),
							_T(".1234567809"),
							_T("123456789012345678"),
							_T("123456789.123456789"),
							_T(".123456789012345678"),
							_T("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("1234567890123456789012345678901234567890123456789012345678901234.1234567890123456789012345678901234567890123456789012345678901234"),
							_T(".12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345670"),
							_T("--"), _T("--"), _T("--")
							#ifdef
							, _T("--")
							#endif
#endif
						},
						{
							SQL_C_TCHAR,
							SQL_SUCCESS,
#ifndef _WM
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("-1234.56789"),_T("-5678.12345"),_T("-1234"),_T("6789"),_T("-12345"),_T("56789"),_T("-12340"),_T("-12300.0"),_T("-12345670"),_T("1993-12-30"),_T("11:45:23"),_T("1992-12-31 23:45:23.123456"),_T(""),_T("9876543"),
							_T("0.123456700"),
							_T("1234567890"),
							_T("12345.67800"),
							_T("0.1234567809"),
							_T("123456789012345678"),
							_T("123456789.123456789"),
							_T("0.123456789012345678"),
							_T("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("1234567890123456789012345678901234567890123456789012345678901234.1234567890000000000000000000000000000000000000000000000000000000"),
							_T("0.12345678901234567890123456789012345678901234567890123456789012345678901234567890000000000000000000000000000000000000000000000000"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#else
							_T("--"), _T("--"), 
							_T("--"), _T("--"),_T("-1234.56789"),_T("-5678.12345"),_T("-1234"),_T("6789"),_T("-12345"),_T("56789"),_T("-12340"),"-12300.0",_T("-12345670"),_T("93/12/30"),_T("11:45:23"),_T("1992-12-31 23:45:23.123456"),_T(""),_T("9876543"),
							_T(".123456700"),
							_T("1234567890"),
							_T("12345.67800"),
							_T(".1234567809"),
							_T("123456789012345678"),
							_T("123456789.123456789"),
							_T(".123456789012345678"),
							_T("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"),
							_T("1234567890123456789012345678901234567890123456789012345678901234.1234567890000000000000000000000000000000000000000000000000000000"),
							_T(".12345678901234567890123456789012345678901234567890123456789012345678901234567890000000000000000000000000000000000000000000000000"),
							_T("--"), _T("--"), _T("--")
							#ifdef UNICODE
							, _T("--")
							#endif
#endif
						},
						{999}};

	TCHAR			*CCharOutput[MAX_NUM1];
	SQLLEN			OutputLen1[MAX_NUM1]; 

	TCHAR			*TestSQLType[] = {
										_T("SQL_CHAR"),			_T("SQL_VARCHAR"),			_T("SQL_DECIMAL"),
										_T("SQL_NUMERIC"),		_T("SQL_SMALLINT"),			_T("SQL_SMALLINT UNSIGNED"),
										_T("SQL_INTEGER"),		_T("SQL_INTEGER UNSIGNED"),	_T("SQL_REAL"),
										_T("SQL_FLOAT"),		_T("SQL_DOUBLE"),			_T("SQL_LONGVARCHAR"),
										_T("SQL_BIGINT"),		_T("SQL_WCHAR"),			_T("SQL_WVARCHAR"),
										_T("SQL_WLONGVARCHAR")
										#ifdef UNICODE
										,	_T("SQL_WCHAR"),	_T("SQL_WVARCHAR"),  _T("SQL_WLONGVARCHAR")
										#endif
									};
	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		unsigned char	OutputValue[MAX_NUM2];
	} SQLDataValueTOC2A[] = {
#ifdef UNICODE
			{SQL_C_BIT,SQL_SUCCESS,_T("--"),_T("('1','0',1.0,0.0,1,1,1,1,1,0,1,'1',1,_UCS2'1',_UCS2'1',_UCS2'1',_UTF8'1',_UTF8'1',_UTF8'1')"),1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
			{SQL_C_UTINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,123,123,123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123',_UTF8'123',_UTF8'123',_UTF8'123')"),123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123},
			{SQL_C_BIT,SQL_SUCCESS,_T("--"),_T("('1','0',1.0,0.0,1,1,1,1,1,0,1,'1',1,_UCS2'1',_UCS2'1',_UCS2'1',_UTF8'1',_UTF8'1',_UTF8'1')"),1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
            {SQL_C_UTINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,123,123,123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123',_UTF8'123',_UTF8'123',_UTF8'123')"),123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123},
#else
			{SQL_C_BIT,SQL_SUCCESS,_T("--"),_T("('1','0',1.0,0.0,1,1,1,1,1,0,1,'1',1,_UCS2'1',_UCS2'1',_UCS2'1')"),1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1},
			{SQL_C_UTINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,123,123,123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123')"),123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123},
			{SQL_C_BIT,SQL_SUCCESS,_T("--"),_T("('1','0',1.0,0.0,1,1,1,1,1,0,1,'1',1,_UCS2'1',_UCS2'1',_UCS2'1')"),1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1},
            {SQL_C_UTINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,123,123,123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123')"),123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123},
#endif
			{999}};

	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		signed char		OutputValue[MAX_NUM2];
	} SQLDataValueTOC2B[] = {
#ifdef UNICODE
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123',_UTF8'123',_UTF8'123',_UTF8'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123,123,123,123},
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123',_UTF8'-123',_UTF8'-123',_UTF8'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123',_UTF8'123',_UTF8'123',_UTF8'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123,123,123,123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123',_UTF8'-123',_UTF8'-123',_UTF8'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123},
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123',_UTF8'123',_UTF8'123',_UTF8'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123,123,123,123},
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123',_UTF8'-123',_UTF8'-123',_UTF8'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123',_UTF8'123',_UTF8'123',_UTF8'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123,123,123,123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123',_UTF8'-123',_UTF8'-123',_UTF8'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123,-123},
#else
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123},
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123},
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123},
						{SQL_C_STINYINT,SQL_SUCCESS,_T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('123','123',123,123,-123,123,-123,123,123,123,123,'123',123,_UCS2'123',_UCS2'123',_UCS2'123')"),123,123,123,123,-123,123,-123,123,123,123,123,123,123,123,123,123},
						{SQL_C_TINYINT,SQL_SUCCESS, _T("--"),_T("('-123','-123',-123,-123,-123,123,-123,123,-123,-123,-123,'-123',-123,_UCS2'-123',_UCS2'-123',_UCS2'-123')"),-123,-123,-123,-123,-123,123,-123,123,-123,-123,-123,-123,-123,-123,-123,-123},
#endif                        
						{999}};

	unsigned char	CBitOutput[MAX_NUM2];
	signed char		CSTinyintOutput[MAX_NUM2];
	unsigned char	CUTinyintOutput[MAX_NUM2];
	signed char		CTinyintOutput[MAX_NUM2];

	struct
	{
		SQLSMALLINT CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		short int		OutputValue[MAX_NUM2];
	} SQLDataValueTOC3A[] = {
#ifdef UNICODE
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012',_UTF8'1234',_UTF8'5678',_UTF8'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012,1234,5678,9012},
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012',_UTF8'-1234',_UTF8'-5678',_UTF8'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012,-1234,-5678,-9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012',_UTF8'1234',_UTF8'5678',_UTF8'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012,1234,5678,9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012',_UTF8'-1234',_UTF8'-5678',_UTF8'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012,-1234,-5678,-9012},
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012',_UTF8'1234',_UTF8'5678',_UTF8'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012,1234,5678,9012},
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012',_UTF8'-1234',_UTF8'-5678',_UTF8'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012,-1234,-5678,-9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012',_UTF8'1234',_UTF8'5678',_UTF8'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012,1234,5678,9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012',_UTF8'-1234',_UTF8'-5678',_UTF8'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012,-1234,-5678,-9012},
#else
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012},
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012},
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012},
						{SQL_C_SSHORT,SQL_SUCCESS,_T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('1234','5678',1234,5678,-1234,6789,-2345,6789,3456,6789,4567,'9012',-3456,_UCS2'1234',_UCS2'5678',_UCS2'9012')"),1234,5678,1234,5678,-1234,6789,-2345,6789,3456,6789,4567,9012,-3456,1234,5678,9012},
						{SQL_C_SHORT,SQL_SUCCESS, _T("--"),_T("('-1234','-5678',-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,'-9012',-3456,_UCS2'-1234',_UCS2'-5678',_UCS2'-9012')"),-1234,-5678,-1234,-5678,-1234,6789,-2345,6789,-3456,-6789,-4567,-9012,-3456,-1234,-5678,-9012},
#endif
						{999}};
	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		TCHAR			*TestCType;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		unsigned short int	OutputValue[MAX_NUM2];
	} SQLDataValueTOC3B[] = {
#ifdef UNICODE 
						{SQL_C_USHORT,SQL_SUCCESS,_T("SQL_C_USHORT"),_T("--"),_T("('1234','5678',1234,5678,1234,6789,2345,6789,3456,6789,4567,'9012',3456,_UCS2'1234',_UCS2'5678',_UCS2'9012',_UTF8'1234',_UTF8'5678',_UTF8'9012')"),1234,5678,1234,5678,1234,6789,2345,6789,3456,6789,4567,9012,3456,1234,5678,9012,1234,5678,9012},
						{SQL_C_USHORT,SQL_SUCCESS,_T("SQL_C_USHORT"),_T("--"),_T("('1234','5678',1234,5678,1234,6789,2345,6789,3456,6789,4567,'9012',3456,_UCS2'1234',_UCS2'5678',_UCS2'9012',_UTF8'1234',_UTF8'5678',_UTF8'9012')"),1234,5678,1234,5678,1234,6789,2345,6789,3456,6789,4567,9012,3456,1234,5678,9012,1234,5678,9012},
#else
						{SQL_C_USHORT,SQL_SUCCESS,_T("SQL_C_USHORT"),_T("--"),_T("('1234','5678',1234,5678,1234,6789,2345,6789,3456,6789,4567,'9012',3456,_UCS2'1234',_UCS2'5678',_UCS2'9012')"),1234,5678,1234,5678,1234,6789,2345,6789,3456,6789,4567,9012,3456,1234,5678,9012},
						{SQL_C_USHORT,SQL_SUCCESS,_T("SQL_C_USHORT"),_T("--"),_T("('1234','5678',1234,5678,1234,6789,2345,6789,3456,6789,4567,'9012',3456,_UCS2'1234',_UCS2'5678',_UCS2'9012')"),1234,5678,1234,5678,1234,6789,2345,6789,3456,6789,4567,9012,3456,1234,5678,9012},
                        
#endif
						{999}};

	struct
	{
		SQLSMALLINT CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		long int		OutputValue[MAX_NUM2];
	} SQLDataValueTOC3C[] = {
#ifdef UNICODE
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345',_UTF8'123456',_UTF8'567890',_UTF8'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345,123456,567890,12345},
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345',_UTF8'-123456',_UTF8'-567890',_UTF8'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345,-123456,-567890,-12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345',_UTF8'123456',_UTF8'567890',_UTF8'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345,123456,567890,12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345',_UTF8'-123456',_UTF8'-567890',_UTF8'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345,-123456,-567890,-12345},
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345',_UTF8'123456',_UTF8'567890',_UTF8'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345,123456,567890,12345},
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345',_UTF8'-123456',_UTF8'-567890',_UTF8'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345,-123456,-567890,-12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345',_UTF8'123456',_UTF8'567890',_UTF8'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345,123456,567890,12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345',_UTF8'-123456',_UTF8'-567890',_UTF8'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345,-123456,-567890,-12345},
#else
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345},
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345},
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345},
						{SQL_C_SLONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,-1234,6789,-23456,67890,34567,67890,45678,'12345',345678,_UCS2'123456',_UCS2'567890',_UCS2'12345')"),123456,567890,12345,56789,-1234,6789,-23456,67890,34567,67890,45678,12345,345678,123456,567890,12345},
						{SQL_C_LONG,SQL_SUCCESS,_T("--"),_T("('-123456','-567890',-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,'-12345',-345678,_UCS2'-123456',_UCS2'-567890',_UCS2'-12345')"),-123456,-567890,-12345,-56789,-1234,6789,-23456,67890,-34567,-67890,-45678,-12345,-345678,-123456,-567890,-12345},
                        
#endif
						{999}};
	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		unsigned long int	OutputValue[MAX_NUM2];
	} SQLDataValueTOC3D[] = {
#ifdef UNICODE
						{SQL_C_ULONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,1234,6789,23456,67890,34567,67890,45678,'123456',456789,_UCS2'123456',_UCS2'567890',_UCS2'123456',_UTF8'123456',_UTF8'567890',_UTF8'123456')"),123456,567890,12345,56789,1234,6789,23456,67890,34567,67890,45678,123456,456789,123456,567890,123456,123456,567890,123456},
						{SQL_C_ULONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,1234,6789,23456,67890,34567,67890,45678,'123456',456789,_UCS2'123456',_UCS2'567890',_UCS2'123456',_UTF8'123456',_UTF8'567890',_UTF8'123456')"),123456,567890,12345,56789,1234,6789,23456,67890,34567,67890,45678,123456,456789,123456,567890,123456,123456,567890,123456},
#else
						{SQL_C_ULONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,1234,6789,23456,67890,34567,67890,45678,'123456',456789,_UCS2'123456',_UCS2'567890',_UCS2'123456')"),123456,567890,12345,56789,1234,6789,23456,67890,34567,67890,45678,123456,456789,123456,567890,123456},
						{SQL_C_ULONG,SQL_SUCCESS,_T("--"),_T("('123456','567890',12345,56789,1234,6789,23456,67890,34567,67890,45678,'123456',456789,_UCS2'123456',_UCS2'567890',_UCS2'123456')"),123456,567890,12345,56789,1234,6789,23456,67890,34567,67890,45678,123456,456789,123456,567890,123456},
                        
#endif
						{999}};

	short int			CSShortOutput[MAX_NUM2];
	unsigned short int	CUShortOutput[MAX_NUM2];
	short int			CShortOutput[MAX_NUM2];
	int					CSLongOutput[MAX_NUM2]; // SQL_C_LONG corresponds to a 32 bit container, so changed this from a long to int
	unsigned int		CULongOutput[MAX_NUM2]; // SQL_C_ULONG corresponds to a 32 bit container, so changed this from a long to int
	int					CLongOutput[MAX_NUM2];	// SQL_C_LONG corresponds to a 32 bit container, so changed this from a long to int

	struct
	{
		SQLSMALLINT CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		float			OutputValue[MAX_NUM2];
	} SQLDataValueTOC4A[] = {
#ifdef UNICODE
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.123,1234,6789,2345,6789,3456.12,6789.34,4567.56,'3456.89',6789,_UCS2'1234.56',_UCS2'5678.90',_UCS2'3456.89',_UTF8'1234.56',_UTF8'5678.90',_UTF8'3456.89')"),(float)1234.56,(float)5678.90,(float)1234.56789,(float)5678.123,(float)1234.0,(float)6789.0,(float)2345.0,(float)6789.0,(float)3456.12,(float)6789.34,(float)4567.56,(float)3456.89,(float)6789.0,(float)1234.56,(float)5678.90,(float)3456.89,(float)1234.56,(float)5678.90,(float)3456.89},
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.123,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-3456.89',-6789,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-3456.89',_UTF8'-1234.56',_UTF8'-5678.90',_UTF8'-3456.89')"),(float)-1234.56,(float)-5678.90,(float)-1234.56789,(float)-5678.123,(float)-1234.0,(float)6789.0,(float)-2345.0,(float)6789.0,(float)-3456.12,(float)-6789.34,(float)-4567.56,(float)-3456.89,(float)-6789.0,(float)-1234.56,(float)-5678.90,(float)-3456.89,(float)-1234.56,(float)-5678.90,(float)-3456.89},
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.123,1234,6789,2345,6789,3456.12,6789.34,4567.56,'3456.89',6789,_UCS2'1234.56',_UCS2'5678.90',_UCS2'3456.89',_UTF8'1234.56',_UTF8'5678.90',_UTF8'3456.89')"),(float)1234.56,(float)5678.90,(float)1234.56789,(float)5678.123,(float)1234.0,(float)6789.0,(float)2345.0,(float)6789.0,(float)3456.12,(float)6789.34,(float)4567.56,(float)3456.89,(float)6789.0,(float)1234.56,(float)5678.90,(float)3456.89,(float)1234.56,(float)5678.90,(float)3456.89},
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.123,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-3456.89',-6789,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-3456.89',_UTF8'-1234.56',_UTF8'-5678.90',_UTF8'-3456.89')"),(float)-1234.56,(float)-5678.90,(float)-1234.56789,(float)-5678.123,(float)-1234.0,(float)6789.0,(float)-2345.0,(float)6789.0,(float)-3456.12,(float)-6789.34,(float)-4567.56,(float)-3456.89,(float)-6789.0,(float)-1234.56,(float)-5678.90,(float)-3456.89,(float)-1234.56,(float)-5678.90,(float)-3456.89},
#else
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.123,1234,6789,2345,6789,3456.12,6789.34,4567.56,'3456.89',6789,_UCS2'1234.56',_UCS2'5678.90',_UCS2'3456.89')"),(float)1234.56,(float)5678.90,(float)1234.56789,(float)5678.123,(float)1234.0,(float)6789.0,(float)2345.0,(float)6789.0,(float)3456.12,(float)6789.34,(float)4567.56,(float)3456.89,(float)6789.0,(float)1234.56,(float)5678.90,(float)3456.89},
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.123,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-3456.89',-6789,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-3456.89')"),(float)-1234.56,(float)-5678.90,(float)-1234.56789,(float)-5678.123,(float)-1234.0,(float)6789.0,(float)-2345.0,(float)6789.0,(float)-3456.12,(float)-6789.34,(float)-4567.56,(float)-3456.89,(float)-6789.0,(float)-1234.56,(float)-5678.90,(float)-3456.89},
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.123,1234,6789,2345,6789,3456.12,6789.34,4567.56,'3456.89',6789,_UCS2'1234.56',_UCS2'5678.90',_UCS2'3456.89')"),(float)1234.56,(float)5678.90,(float)1234.56789,(float)5678.123,(float)1234.0,(float)6789.0,(float)2345.0,(float)6789.0,(float)3456.12,(float)6789.34,(float)4567.56,(float)3456.89,(float)6789.0,(float)1234.56,(float)5678.90,(float)3456.89},
						{SQL_C_FLOAT,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.123,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-3456.89',-6789,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-3456.89')"),(float)-1234.56,(float)-5678.90,(float)-1234.56789,(float)-5678.123,(float)-1234.0,(float)6789.0,(float)-2345.0,(float)6789.0,(float)-3456.12,(float)-6789.34,(float)-4567.56,(float)-3456.89,(float)-6789.0,(float)-1234.56,(float)-5678.90,(float)-3456.89},

#endif
						{999}};
	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		double			OutputValue[MAX_NUM2];
	} SQLDataValueTOC4B[] = {
#ifdef UNICODE
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.12345,1234,6789,2345,6789,3456.12,6789.34,4567.56,'34567.89',67890,_UCS2'1234.56',_UCS2'5678.90',_UCS2'34567.89',_UTF8'1234.56',_UTF8'5678.90',_UTF8'34567.89')"),1234.56,5678.90,1234.56789,5678.12345,1234.0,6789.0,2345.0,6789.0,3456.12,6789.34,4567.56,34567.89,67890.0,1234.56,5678.90,34567.89,1234.56,5678.90,34567.89},
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.12345,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-34567.89',-67890,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-34567.89',_UTF8'-1234.56',_UTF8'-5678.90',_UTF8'-34567.89')"),-1234.56,-5678.90,-1234.56789,-5678.12345,-1234.0,6789.0,-2345.0,6789.0,-3456.12,-6789.34,-4567.56,-34567.89,-67890.0,-1234.56,-5678.90,-34567.89,-1234.56,-5678.90,-34567.89},
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.12345,1234,6789,2345,6789,3456.12,6789.34,4567.56,'34567.89',67890,_UCS2'1234.56',_UCS2'5678.90',_UCS2'34567.89',_UTF8'1234.56',_UTF8'5678.90',_UTF8'34567.89')"),1234.56,5678.90,1234.56789,5678.12345,1234.0,6789.0,2345.0,6789.0,3456.12,6789.34,4567.56,34567.89,67890.0,1234.56,5678.90,34567.89,1234.56,5678.90,34567.89},
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.12345,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-34567.89',-67890,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-34567.89',_UTF8'-1234.56',_UTF8'-5678.90',_UTF8'-34567.89')"),-1234.56,-5678.90,-1234.56789,-5678.12345,-1234.0,6789.0,-2345.0,6789.0,-3456.12,-6789.34,-4567.56,-34567.89,-67890.0,-1234.56,-5678.90,-34567.89,-1234.56,-5678.90,-34567.89},
#else
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.12345,1234,6789,2345,6789,3456.12,6789.34,4567.56,'34567.89',67890,_UCS2'1234.56',_UCS2'5678.90',_UCS2'34567.89')"),1234.56,5678.90,1234.56789,5678.12345,1234.0,6789.0,2345.0,6789.0,3456.12,6789.34,4567.56,34567.89,67890.0,1234.56,5678.90,34567.89},
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.12345,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-34567.89',-67890,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-34567.89')"),-1234.56,-5678.90,-1234.56789,-5678.12345,-1234.0,6789.0,-2345.0,6789.0,-3456.12,-6789.34,-4567.56,-34567.89,-67890.0,-1234.56,-5678.90,-34567.89},
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('1234.56','5678.90',1234.56789,5678.12345,1234,6789,2345,6789,3456.12,6789.34,4567.56,'34567.89',67890,_UCS2'1234.56',_UCS2'5678.90',_UCS2'34567.89')"),1234.56,5678.90,1234.56789,5678.12345,1234.0,6789.0,2345.0,6789.0,3456.12,6789.34,4567.56,34567.89,67890.0,1234.56,5678.90,34567.89},
						{SQL_C_DOUBLE,SQL_SUCCESS,_T("--"),_T("('-1234.56','-5678.90',-1234.56789,-5678.12345,-1234,6789,-2345,6789,-3456.12,-6789.34,-4567.56,'-34567.89',-67890,_UCS2'-1234.56',_UCS2'-5678.90',_UCS2'-34567.89')"),-1234.56,-5678.90,-1234.56789,-5678.12345,-1234.0,6789.0,-2345.0,6789.0,-3456.12,-6789.34,-4567.56,-34567.89,-67890.0,-1234.56,-5678.90,-34567.89},

#endif
						{999}};

	float			CFloatOutput[MAX_NUM2];
	double			CDoubleOutput[MAX_NUM2];
	SQLLEN			OutputLen2[MAX_NUM2]; 

	TCHAR			*TestSQLType1[] = {_T("SQL_CHAR"),_T("SQL_VARCHAR"),_T("SQL_DATE"),_T("SQL_TIMESTAMP"),_T("SQL_LONGVARCHAR"),
										_T("SQL_WCHAR"),_T("SQL_WVARCHAR"),_T("SQL_WLONGVARCHAR"),_T("SQL_WLONGVARCHAR")};
	struct
	{
		SQLSMALLINT CType;
		RETCODE			rcode;
		TCHAR			*InsCol;
		int				yr[MAX_DATETIME];
		int				mn[MAX_DATETIME];
		int				dt[MAX_DATETIME];
	} SQLDataValueTOC5[] = {
#ifdef UNICODE
						{  SQL_C_DATE,SQL_SUCCESS,
							_T("('1997-10-11','1999-01-01',{d '1993-12-30'},{ts '1992-12-31 00:00:00'},'1998-04-23',_UCS2'1997-10-11',_UCS2'1999-01-01',_UCS2'1998-04-23',_UTF8'1998-04-23')"),
#ifndef _WM
							1997,1999,1993,1992,1998,1997,1999,1998,1998,
#else
							1997,1999,93,1992,1998,1997,1999,1998,1998,
#endif
							10,01,12,12,04,10,01,04,04,
							11,01,30,31,23,11,01,23,23
						},
#else
						{  SQL_C_DATE,SQL_SUCCESS,
							_T("('1997-10-11','1999-01-01',{d '1993-12-30'},{ts '1992-12-31 00:00:00'},'1998-04-23',_UCS2'1997-10-11',_UCS2'1999-01-01',_UCS2'1998-04-23')"),
#ifndef _WM
							1997,1999,1993,1992,1998,1997,1999,1998,
#else
							1997,1999,93,1992,1998,1997,1999,1998,
#endif
							10,01,12,12,04,10,01,04,
							11,01,30,31,23,11,01,23
						},
#endif
						{   999 }};

	DATE_STRUCT	CDateOutput[MAX_DATETIME];
	TCHAR	*TestSQLType2[] = {_T("SQL_CHAR"),_T("SQL_VARCHAR"),_T("SQL_TIME"),_T("SQL_TIMESTAMP"),_T("SQL_LONGVARCHAR"),
								_T("SQL_WCHAR"),_T("SQL_WVARCHAR"),_T("SQL_WLONGVARCHAR"),_T("SQL_WLONGVARCHAR")};
	struct
	{
		SQLSMALLINT CType;
		RETCODE			rcode;
		TCHAR			*InsCol;
		int				hr[MAX_DATETIME];
		int				mn[MAX_DATETIME];
		int				sc[MAX_DATETIME];
	} SQLDataValueTOC6[] = 
						{{  SQL_C_TIME,SQL_SUCCESS,
#ifdef UNICODE
							_T("('03:45:04','15:29:42',{t '10:11:12'},{ts '1992-12-31 23:45:23.123456'},'12:30:56',_UCS2'03:45:04',_UCS2'15:29:42',_UCS2'12:30:56',_UTF8'12:30:56')"),
							3,15,10,23,12,3,15,12,12,
							45,29,11,45,30,45,29,30,30,
							4,42,12,23,56,4,42,56,56
#else
							_T("('03:45:04','15:29:42',{t '10:11:12'},{ts '1992-12-31 23:45:23.123456'},'12:30:56',_UCS2'03:45:04',_UCS2'15:29:42',_UCS2'12:30:56')"),
							3, 15,10,23,12,3, 15,12,
							45,29,11,45,30,45,29,30,
							4, 42,12,23,56,4, 42,56
#endif
						},
						{   999, }};

	TIME_STRUCT	CTimeOutput[MAX_DATETIME];
	TCHAR	*TestSQLType3[] = {_T("SQL_CHAR"),_T("SQL_VARCHAR"),_T("SQL_DATE"),_T("SQL_TIME"),_T("SQL_TIMESTAMP"),_T("SQL_LONGVARCHAR"),
								_T("SQL_WCHAR"),_T("SQL_WVARCHAR"),_T("SQL_WLONGVARCHAR"),_T("SQL_WLONGVARCHAR")};
	struct
	{
		SQLSMALLINT CType;
		RETCODE			rcode;
		TCHAR			*InsCol;
		SWORD			yr[MAX_TIMESTAMP];
		UWORD			mon[MAX_TIMESTAMP];
		UWORD			dt[MAX_TIMESTAMP];
		UWORD			hr[MAX_TIMESTAMP];
		UWORD			min[MAX_TIMESTAMP];
		UWORD			sc[MAX_TIMESTAMP];
		SQLULEN			fr[MAX_TIMESTAMP];
	} SQLDataValueTOC7[] = 
						{
#ifdef UNICODE
							{
								SQL_C_TIMESTAMP,SQL_SUCCESS,
								_T("('1997-10-11 03:45:04.34','1999-01-01 15:29:42.321',{d '1993-12-30'},{t '10:11:12'},{ts '1992-12-31 23:45:23.123456'},'1998-12-23 10:49:02.654321',_UCS2'1997-10-11 03:45:04.34',_UCS2'1999-01-01 15:29:42.321',_UCS2'1998-12-23 10:49:02.654321',_UTF8'1998-12-23 10:49:02.654321')"),
							#ifndef _WM
								1997,1999,1993,0,1992,1998,1997,1999,1998,1998,
							#else
								1997,1999,93,0,1992,1998,1997,1999,1998,1998,
							#endif
								10,01,12,0,12,12,10,01,12,12,
								11,01,30,0,31,23,11,01,23,23,
								3,15,0,10,23,10,3,15,10,10,
								45,29,0,11,45,49,45,29,49,49,
								4,42,0,12,23,02,4,42,02,02,
								340000000,321000000,0,0,123456000,654321000,340000000,321000000,654321000,654321000
							},
#else
														{
								SQL_C_TIMESTAMP,SQL_SUCCESS,
								_T("('1997-10-11 03:45:04.34','1999-01-01 15:29:42.321',{d '1993-12-30'},{t '10:11:12'},{ts '1992-12-31 23:45:23.123456'},'1998-12-23 10:49:02.654321',_UCS2'1997-10-11 03:45:04.34',_UCS2'1999-01-01 15:29:42.321',_UCS2'1998-12-23 10:49:02.654321')"),
#ifndef _WM
								1997,1999,1993,0,1992,1998,1997,1999,1998,
#else
								1997,1999,93,0,1992,1998,1997,1999,1998,
#endif
								10,01,12,0, 12,12,10,01,12,
								11,01,30,0, 31,23,11,01,23,
								3, 15,0, 10,23,10,3, 15,10,
								45,29,0, 11,45,49,45,29,49,
								4, 42,0, 12,23,02,4, 42,02,
								340000000,321000000,0,0,123456000,654321000,340000000,321000000,654321000
							},
#endif
							{
								999,
							}
						};
	TIMESTAMP_STRUCT	CTimestampOutput[MAX_TIMESTAMP];

	struct
	{
		SQLSMALLINT				CType;
		RETCODE					rcode;
		TCHAR					*CrtCol;
		TCHAR					*InsCol;
		TCHAR					*OutputCharDef;
		TCHAR					*OutputVCharDef;
		char					*OutputDecDef;	//For SQL_C_DEFAULT, unicode data is returned with nchar and nvarchar columns only
		char					*OutputNumDef; //For SQL_C_DEFAULT, unicode data is returned with nchar and nvarchar columns only
		signed short int		OutputSSintDef;
		unsigned short int		OutputUSintDef;
		int						OutputSLintDef;
		char					*OutputULintDef;
		float					OutputRealDef;
		double					OutputFloatDef;
		double					OutputDoubleDef;
#ifndef _WM
		DATE_STRUCT             OutputDateDef;
#else
        TCHAR                    OutputDateDef[10];  // return SQL_DATE as a string
#endif
		TIME_STRUCT             OutputTimeDef;
		TIMESTAMP_STRUCT        OutputTimestampDef;
		TCHAR					*OutputLVCharDef;
		char					*OutputBigintDef; //For SQL_C_DEFAULT, unicode data is returned with nchar and nvarchar columns only
		TCHAR					*OutputNCharDef;
		TCHAR					*OutputNVCharDef;
		TCHAR					*OutputNLVCharDef;
#ifdef UNICODE
		TCHAR					*OutputNLVUTF8CharDef;
#endif
	} SQLDataValueTOCDef[] = {// real, float and double precision to TCHAR has problem it returns 12345.0 values as 12345.
#ifndef _WM
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"1","2",-3,4,-5,"6",7,8,9,{1997,1,2},{3,4,5},{1997,6,7,8,9,10,0},_T("--"),"10",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"9876.54321","9876.54321",-1234,6789,-12345,"56789",(float)1234.56,98765.432,1234567.891,{1993,12,30},{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"-9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"1234.56789","5678.12345",-1234,6789,-12345,"56789",12340,12300,12345670,{1993,12,30},{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"-9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"-1234.56789","-5678.12345",-1234,6789,-12345,"56789",-12340,-12300,-12345670,{1993,12,30},{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"1234.56789","1234567890.01234567890123456789",-1234,6789,-12345,"56789",12340,12300,12345670,{1993,12,30},{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"-9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"-1234.56789","-1234567890.01234567890123456789",-1234,6789,-12345,"56789",-12340,-12300,-12345670,{1993,12,30},{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"-1234.56789","5678.12345",-1234,6789,-12345,"56789",-12340,-12300,-12345670,{1993,12,30},{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},

#else
            {SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"1","2",-3,4,-5,"6",7,8,9,"97/01/02",{3,4,5},{1997,6,7,8,9,10,0},_T("--"),"10",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"9876.54321","9876.54321",-1234,6789,-12345,"56789",(float)1234.56,98765.432,1234567.891,"93/12/30",{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"-9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE			
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"1234.56789","5678.12345",-1234,6789,-12345,"56789",12340,12300,12345670,"93/12/30",{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"-9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE			
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"-1234.56789","-5678.12345",-1234,6789,-12345,"56789",-12340,-12300,-12345670,"93/12/30",{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE			
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"1234.56789","1234567890.01234567890123456789",-1234,6789,-12345,"56789",12340,12300,12345670,"93/12/30",{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"-9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"-1234.56789","-1234567890.01234567890123456789",-1234,6789,-12345,"56789",-12340,-12300,-12345670,"93/12/30",{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE			
			,_T("--")
			#endif
			},
			{SQL_C_DEFAULT,SQL_SUCCESS,_T("--"),_T("--"),_T("--"),_T("--"),"-1234.56789","5678.12345",-1234,6789,-12345,"56789",-12340,-12300,-12345670,"93/12/30",{11,45,23},{1992,12,31,23,45,23,123456000},_T("--"),"9876543",_T("--"),_T("--"),_T("--")
			#ifdef UNICODE			
			,_T("--")
			#endif
			},
#endif
			{999}};

	char					*CharDefOutput;
	char					*VCharDefOutput;
	char					*DecDefOutput;
	char					*NumDefOutput;
	signed short int		SSintDefOutput = 0;
	unsigned short int		USintDefOutput = 0;
	int	  			        SLintDefOutput = 0; // SQL_C_LONG is a 32 bit container
	char					*ULintDefOutput = 0;
	float					RealDefOutput = 0;
	double					FloatDefOutput = 0;
	double					DoubleDefOutput = 0;
#ifndef _WM
	DATE_STRUCT				DateDefOutput;
#else
    TCHAR                    DateDefOutput[10];  // SQL_DATE returned as a string
#endif
	TIME_STRUCT				TimeDefOutput;
	TIMESTAMP_STRUCT		TimestampDefOutput;
	char					*LVCharDefOutput;
	char					*BigintDefOutput;
	wchar_t					*CharDefOutputUCS2;
	wchar_t					*VCharDefOutputUCS2;
	wchar_t					*LVCharDefOutputUCS2;
	wchar_t					*NLVUTF8CharDefOutput;
	SQLLEN					DefOutputLen[MAX_NUM4]; 
	TCHAR					conversionbuffer[512];
	int						sizeconversion=0;

	TCHAR					*TestforLessBuf[] = {
													_T("SQL_CHAR"), _T("SQL_VARCHAR"), _T("SQL_LONGVARCHAR"),
													_T("SQL_WCHAR"),_T("SQL_WVARCHAR"),_T("SQL_WLONGVARCHAR")
													#ifdef UNICODE
													,_T("SQL_WLONGVARCHAR")
													#endif
												};
	struct
	{
		SQLSMALLINT		CType;
		RETCODE			rcode;
		SQLINTEGER		OutputLen;
		TCHAR			*CrtCol;
		TCHAR			*InsCol;
		TCHAR			*OutputValue[MAX_NUM3];
	} SQLDataValueforLessBuf[] = {
						{SQL_C_TCHAR,SQL_SUCCESS_WITH_INFO,6,_T("--"),_T("--"),
						#ifdef UNICODE
						_T("--"),_T("--"),_T("--"),_T("--"),_T("--"),_T("--"),_T("--")
						#else
						_T("--"),_T("--"),_T("--"),_T("--"),_T("--"),_T("--")
						#endif
						},
						{999}};
	TCHAR	*COutputlessBuf[MAX_NUM3];
	SQLLEN	OutputLenlessbuf[MAX_NUM3];
	int		i,k;
	TCHAR	InsStr[MAX_NOS_SIZE];
	TCHAR	TempCType[50];

	struct
	{
		SQLSMALLINT			CType;
		RETCODE				rcode;
		TCHAR				*selCol;
		int					expInt;
		TCHAR				*expChar;
		DATE_STRUCT			expDate;
		TIME_STRUCT			expTime;
		TIMESTAMP_STRUCT	expTimeStamp;
	} TimeStampFunction[] = 
		{
			{
				SQL_C_TCHAR, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_WEEK, 1 , DATE '2008-02-28')"),
#ifndef _WM
				0, _T("2008-03-06"),
#else
                0, _T("2008/03/06"),
#endif
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_DATE, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_WEEK, 1 , DATE '2008-02-28')"),
				0, 0,
#ifndef _WM
				2008,03,6,
#else
                8,3,6,
#endif
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_DATE, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_YEAR, -1, DATE '2000-02-29')"),
				0, 0,
#ifndef _WM
				1999,02,28,
#else
                99,2,28,
#endif
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_DATE, SQL_SUCCESS_WITH_INFO, _T("TIMESTAMPADD (SQL_TSI_DAY, -5, TIMESTAMP '2004-02-29 13:27:35')"),
				0, 0,
				2004,02,24,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_TIME, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_MINUTE, -1, TIME '12:00:00')"),
				0, 0,
				0,0,0,
				11,59,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_TIME, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_DAY, -5, TIMESTAMP '2004-02-29 13:27:35')"),
				0, 0,
				0,0,0,
				13,27,35,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_TCHAR, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_MONTH, -12, TIMESTAMP'2004-02-29 13:27:35')"),
				0, _T("2003-02-28 13:27:35"),
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_TIMESTAMP, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_MONTH, -12, TIMESTAMP'2004-02-29 13:27:35')"),
				0, 0,
				0,0,0,
				0,0,0,
				2003,02,28,13,27,35,0
			},
			{
				SQL_C_TIMESTAMP, SQL_SUCCESS, _T("TIMESTAMPADD (SQL_TSI_SECOND, -5, DATE'2008-07-01')"),
				0, 0,
				0,0,0,
				0,0,0,
				2008,06,30,23,59,55,0
			},
			{
				SQL_C_LONG, SQL_SUCCESS, _T("TIMESTAMPDIFF(SQL_TSI_SECOND, TIMESTAMP '2006-09-12 11:59:58.999999', TIMESTAMP '2006-09-12 11:59:59.000000')"),
				1, 0,
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_LONG, SQL_SUCCESS, _T("TIMESTAMPDIFF(SQL_TSI_YEAR, TIMESTAMP '2006-12-31 23:59:59.000000', TIMESTAMP '2006-12-31 23:59:59.999999')"),
				0, 0,
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_LONG, SQL_SUCCESS, _T("TIMESTAMPDIFF(SQL_TSI_DAY, DATE '2004-03-01', DATE '2004-02-01')"),
				-29, 0,
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			//Negative test 
			{
				SQL_C_DATE, SQL_ERROR, _T("TIMESTAMPADD (SQL_TSI_YEAR, 10, DATE '9999-02-28')"),
				0, 0,
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_LONG, SQL_ERROR, _T("TIMESTAMPDIFF(SQL_TSI_SECOND, DATE '1900-03-01', DATE '2004-02-01')"),
				0, 0,
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				SQL_C_LONG, SQL_ERROR, _T("TIMESTAMPDIFF(SQL_TSI_WEEK, DATE '0001-01-02', DATE '2004-02-01')"),
				0, 0,
				0,0,0,
				0,0,0,
				0,0,0,0,0,0,0
			},
			{
				999,
			}
		};

	int					outputInt;
	TCHAR				outputChar[50];
	TIMESTAMP_STRUCT	outputTimeStamp;
	DATE_STRUCT			outputDate;
	TIME_STRUCT			outputTime;
	SQLLEN				outputSize;

//************************************************
	int j = 0;

    struct {
		RETCODE		PassFail;
		TCHAR		*CrtCol;
        TCHAR        *InputValue;
		SFLOAT		ExpectedFloatValue[MAX_NUM5];
    } CFloatToNumeric[] = {
        {
			SQL_SUCCESS, _T("--"),
            _T("12345678, 0.123456, 12.345678, 12345678, 0.123456, 1.23456, 12345678, 12345678, 0.123456, 1.234567, 12345678, 0.123456, 12345678"),
            {(float)12345678.0, (float)0.123456, (float)12.345678, (float)12345678.0, (float)0.123456, (float)1.23456, (float)12345678.0, (float)12345678, (float)0.123456, (float)1.234567, (float)12345678.0, (float)0.123456, (float)12345678.0},
        },
        {
			SQL_SUCCESS, _T("--"),
            _T("-123456, -0.123456, -12.345678, -123456, -0.123456, -1.234567, -123456, -123456, -0.123456, -1.234567, -123456, -0.123456, -123456"),
            {(float)(-123456.0), (float)(-0.123456), (float)(-12.345678), (float)(-123456.0), (float)(-0.123456), (float)(-1.234567), (float)(-123456.0), (float)(-123456), (float)(-0.123456), (float)(-1.234567), (float)(-123456.0), (float)(-0.123456), (float)(-123456.0)},
        },
        {
			SQL_SUCCESS, _T("--"),
            _T("12345678, 0.123456, 12.345678, 12345678, 0.123456, 1.234567, 12345678, 12345678, 0.123456, 1.234567, 12345678, 0.123456, 12345678"),
            {(float)12345678.0, (float)0.123456, (float)12.345678, (float)12345678.0, (float)0.123456, (float)1.234567, (float)12345678.0, (float)12345678, (float)0.123456, (float)1.234567, (float)12345678.0, (float)0.123456, (float)12345678.0},
        },
        {
			SQL_SUCCESS, _T("--"),
            _T("-123456.0, -12345.6, -12345.06, -1.000006, -0.000006, -1234567.0, -0.0000007, 123456.0, 12345.6, 1.000006, 0.000006, 1234567.0, 0.0000007"),
            {(float)(-123456.0), (float)(-12345.6), (float)( -12345.06), (float)(-1.000006), (float)(-0.000006), (float)(-1234567.0), (float)(-0.0000007), (float)(123456.0), (float)(12345.6), (float)(1.000006), (float)(0.000006), (float)(1234567.0), (float)(0.0000007)},
        },
        {999,
        }
    };
//************************************************
    struct {
		RETCODE		PassFail;
		TCHAR		*CrtCol;
        TCHAR        *InputValue;
		SDOUBLE		ExpectedDoubleValue[MAX_NUM5];
    } CDoubleToNumeric[] = {
        {
			SQL_SUCCESS, _T("--"),
            _T("123456789123456, 0.123456789123456, 12.3456789123456, 123456789123456, 0.123456789123456, 1.2345678912345, 123456789123456, 123456789123456, 0.123456789123456, 1.23456789123456, 123456789123456, 0.1234567891, 123456789123456"),
            {(double)123456789123456.0, (double)0.123456789123456, (double)12.3456789123456, (double)123456789123456.0, (double)0.123456789123456, (double)1.23456789123456, (double)123456789123456.0, (double)123456789123456.0, (double)0.123456789123456, (double)1.23456789123456, (double)123456789123456.0, (double)0.1234567891, (double)123456789123456.0},
        },
        {
			SQL_SUCCESS, _T("--"),
            _T("-123456789123456, -0.123456789123456, -12.3456789123456, -123456789123456, -0.123456789123456, -1.23456789123456, -123456789123456, -123456789123456, -0.123456789123456, -1.23456789123456, -123456789123456, -0.1234567891, -123456789123456"),
            {(double)-123456789123456.0, (double)-0.123456789123456, (double)-12.3456789123456, (double)-123456789123456.0, (double)-0.123456789123456, (double)-1.23456789123456, (double)-123456789123456.0, (double)-123456789123456.0, (double)-0.123456789123456, (double)-1.23456789123456, (double)-123456789123456.0, (double)-0.1234567891, (double)-123456789123456.0},
        },
        {
			SQL_SUCCESS, _T("--"),
            _T("12345678, 0.12345678, 12.345678, 12345678, 0.123456, 1.234567, 12345678, 12345678, 0.123456, 1.234567, 12345678, 0.123456, 12345678"),
            {(double)12345678.0, (double)0.12345678, (double)12.345678, (double)12345678.0, (double)0.123456, (double)1.234567, (double)12345678.0, (double)12345678, (double)0.123456, (double)1.234567, (double)12345678.0, (double)0.123456, (double)12345678.0},
        },
        {
			SQL_SUCCESS, _T("--"),
            _T("-123456789123456.0, -12345678912345.6, -12345678912345.06, -1.00000000000006, -0.000000000000006, -123456789123456.0, -0.000000000000006, 123456789123456.0, 12345678912345.6, 1.00000000000006, 0.000000000000006, 123456789123456.0, 0.000000000000006"),
            {(double)-123456789123456.0, (double)-12345678912345.6, (double)-12345678912345.06, (double)-1.00000000000006, (double)-0.000000000000006, (double)-123456789123456.0, (double)-0.000000000000006, (double)123456789123456.0, (double)12345678912345.6, (double)1.00000000000006, (double)0.000000000000006, (double)123456789123456.0, (double)0.000000000000006},
        },
        {999,
        }
    };

	SQLLEN		outSize[MAX_NUM5];
	SFLOAT		FloatOutValue[MAX_NUM5];
	SDOUBLE		DoubleOutValue[MAX_NUM5];

	//===========================================================================================================
	// Negative tests to convert BIGNUM to all CTypes
	unsigned char			*BinaryVal = 0;
	unsigned char			BitVal = 0;
	short int				ShortVal = 0;
	unsigned short int		UShortVal = 0;
	int						LongVal = 0;
	unsigned int			ULongVal = 0;
	signed char				TinyIntVal = 0;
	unsigned char			UTinyIntVal = 0;
	long long int			BigIntVal = 0;
	unsigned long long int	UBigIntVal = 0;
	SQL_INTERVAL_STRUCT		IntevalVal;
	SQL_NUMERIC_STRUCT		NumericVal;

	SQLSMALLINT CTypeAll[] = {
		//SQL_C_BINARY, SQL_C_BIT, 
		//SQL_C_SHORT, SQL_C_SSHORT, SQL_C_USHORT,
		//SQL_C_LONG, SQL_C_SLONG, SQL_C_ULONG,
		//SQL_C_TINYINT, SQL_C_STINYINT, SQL_C_UTINYINT,
		//SQL_C_SBIGINT, SQL_C_UBIGINT,
		//SQL_C_NUMERIC, 
		SQL_C_DATE, SQL_C_TIME, SQL_C_TIMESTAMP,
		SQL_C_INTERVAL_DAY, SQL_C_INTERVAL_DAY_TO_HOUR, SQL_C_INTERVAL_DAY_TO_MINUTE, SQL_C_INTERVAL_DAY_TO_SECOND,
		SQL_C_INTERVAL_HOUR, SQL_C_INTERVAL_HOUR_TO_MINUTE, SQL_C_INTERVAL_HOUR_TO_SECOND,
		SQL_C_INTERVAL_MINUTE, SQL_C_INTERVAL_MINUTE_TO_SECOND, SQL_C_INTERVAL_SECOND,
		SQL_C_INTERVAL_MONTH, SQL_C_INTERVAL_YEAR, SQL_C_INTERVAL_YEAR_TO_MONTH,
		999
	};

	TCHAR	*DrpTab10 = _T("DROP TABLE SQLBINDCOL10");
	TCHAR	*CrtTab10 = _T("CREATE TABLE SQLBINDCOL10 (C1 NUMERIC(128,64)) NO PARTITION");
	TCHAR	*InsTab10 = _T("INSERT INTO SQLBINDCOL10 VALUES (123456789012345678901234567890.12345678901234567890123456789)");
	TCHAR	*SelTab10 = _T("SELECT * FROM SQLBINDCOL10");

//===========================================================================================================
	var_list_t *var_list;
	var_list = load_api_vars(_T("SQLBindColumn"), charset_file);
	if (var_list == NULL) return FAILED;

	DrpTab1 = var_mapping(_T("SQLBindColumn_DrpTab_1"), var_list);
	DrpTab2 = var_mapping(_T("SQLBindColumn_DrpTab_2"), var_list);
	DrpTab3 = var_mapping(_T("SQLBindColumn_DrpTab_3"), var_list);
	DrpTab4 = var_mapping(_T("SQLBindColumn_DrpTab_4"), var_list);
	DrpTab5 = var_mapping(_T("SQLBindColumn_DrpTab_5"), var_list);
	DrpTab6 = var_mapping(_T("SQLBindColumn_DrpTab_6"), var_list);
	DrpTab7 = var_mapping(_T("SQLBindColumn_DrpTab_7"), var_list);
	// DrpTab8 = var_mapping(_T("SQLBindColumn_DrpTab_8"), var_list);

	CrtTab1 = var_mapping(_T("SQLBindColumn_CrtTab_1"), var_list);
	CrtTab2 = var_mapping(_T("SQLBindColumn_CrtTab_2"), var_list);
	CrtTab3 = var_mapping(_T("SQLBindColumn_CrtTab_3"), var_list);
	CrtTab4 = var_mapping(_T("SQLBindColumn_CrtTab_4"), var_list);
	CrtTab5 = var_mapping(_T("SQLBindColumn_CrtTab_5"), var_list);
	CrtTab6 = var_mapping(_T("SQLBindColumn_CrtTab_6"), var_list);
	CrtTab7 = var_mapping(_T("SQLBindColumn_CrtTab_7"), var_list);
	// CrtTab8 = var_mapping(_T("SQLBindColumn_CrtTab_8"), var_list);

	InsTab1 = var_mapping(_T("SQLBindColumn_InsTab_1"), var_list);
	InsTab2 = var_mapping(_T("SQLBindColumn_InsTab_2"), var_list);
	InsTab3 = var_mapping(_T("SQLBindColumn_InsTab_3"), var_list);
	InsTab4 = var_mapping(_T("SQLBindColumn_InsTab_4"), var_list);
	InsTab5 = var_mapping(_T("SQLBindColumn_InsTab_5"), var_list);
	InsTab6 = var_mapping(_T("SQLBindColumn_InsTab_6"), var_list);
	InsTab7 = var_mapping(_T("SQLBindColumn_InsTab_7"), var_list);
	// InsTab8 = var_mapping(_T("SQLBindColumn_InsTab_8"), var_list);

	SelTab1 = var_mapping(_T("SQLBindColumn_SelTab_1"), var_list);
	SelTab2 = var_mapping(_T("SQLBindColumn_SelTab_2"), var_list);
	SelTab3 = var_mapping(_T("SQLBindColumn_SelTab_3"), var_list);
	SelTab4 = var_mapping(_T("SQLBindColumn_SelTab_4"), var_list);
	SelTab5 = var_mapping(_T("SQLBindColumn_SelTab_5"), var_list);
	SelTab6 = var_mapping(_T("SQLBindColumn_SelTab_6"), var_list);
	SelTab7 = var_mapping(_T("SQLBindColumn_SelTab_7"), var_list);
	// SelTab8 = var_mapping(_T("SQLBindColumn_SelTab_8"), var_list);

	////////////////////////////////////////////////////////////////////////////////////////////

	SQLDataValueTOC1[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC1_CrtCol_0"), var_list);
	SQLDataValueTOC1[0].InsCol = var_mapping(_T("SQLBindColumn_TOC1_InsCol_0"), var_list);
	SQLDataValueTOC1[0].OutputValue[0] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue0_0"), var_list);
	SQLDataValueTOC1[0].OutputValue[1] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue1_0"), var_list);
	SQLDataValueTOC1[0].OutputValue[14] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue14_0"), var_list);
	SQLDataValueTOC1[0].OutputValue[26] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue26_0"), var_list);
	SQLDataValueTOC1[0].OutputValue[27] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue27_0"), var_list);
	SQLDataValueTOC1[0].OutputValue[28] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue28_0"), var_list);

	SQLDataValueTOC1[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC1_CrtCol_1"), var_list);
	SQLDataValueTOC1[1].InsCol = var_mapping(_T("SQLBindColumn_TOC1_InsCol_1"), var_list);
	SQLDataValueTOC1[1].OutputValue[0] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue0_1"), var_list);
	SQLDataValueTOC1[1].OutputValue[1] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue1_1"), var_list);
	SQLDataValueTOC1[1].OutputValue[14] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue14_1"), var_list);
	SQLDataValueTOC1[1].OutputValue[26] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue26_1"), var_list);
	SQLDataValueTOC1[1].OutputValue[27] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue27_1"), var_list);
	SQLDataValueTOC1[1].OutputValue[28] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue28_1"), var_list);

	SQLDataValueTOC1[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC1_CrtCol_2"), var_list);
	SQLDataValueTOC1[2].InsCol = var_mapping(_T("SQLBindColumn_TOC1_InsCol_2"), var_list);
	SQLDataValueTOC1[2].OutputValue[0] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue0_2"), var_list);
	SQLDataValueTOC1[2].OutputValue[1] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue1_2"), var_list);
	SQLDataValueTOC1[2].OutputValue[14] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue14_2"), var_list);
	SQLDataValueTOC1[2].OutputValue[26] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue26_2"), var_list);
	SQLDataValueTOC1[2].OutputValue[27] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue27_2"), var_list);
	SQLDataValueTOC1[2].OutputValue[28] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue28_2"), var_list);

	SQLDataValueTOC1[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC1_CrtCol_3"), var_list);
	SQLDataValueTOC1[3].InsCol = var_mapping(_T("SQLBindColumn_TOC1_InsCol_3"), var_list);
	SQLDataValueTOC1[3].OutputValue[0] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue0_3"), var_list);
	SQLDataValueTOC1[3].OutputValue[1] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue1_3"), var_list);
	SQLDataValueTOC1[3].OutputValue[14] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue14_3"), var_list);
	SQLDataValueTOC1[3].OutputValue[26] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue26_3"), var_list);
	SQLDataValueTOC1[3].OutputValue[27] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue27_3"), var_list);
	SQLDataValueTOC1[3].OutputValue[28] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue28_3"), var_list);
	
	SQLDataValueTOC1[4].CrtCol = var_mapping(_T("SQLBindColumn_TOC1_CrtCol_4"), var_list);
	SQLDataValueTOC1[4].InsCol = var_mapping(_T("SQLBindColumn_TOC1_InsCol_4"), var_list);
	SQLDataValueTOC1[4].OutputValue[0] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue0_4"), var_list);
	SQLDataValueTOC1[4].OutputValue[1] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue1_4"), var_list);
	SQLDataValueTOC1[4].OutputValue[14] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue14_4"), var_list);
	SQLDataValueTOC1[4].OutputValue[26] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue26_4"), var_list);
	SQLDataValueTOC1[4].OutputValue[27] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue27_4"), var_list);
	SQLDataValueTOC1[4].OutputValue[28] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue28_4"), var_list);

#ifdef UNICODE
	SQLDataValueTOC1[0].OutputValue[29] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue29_0"), var_list);
	SQLDataValueTOC1[1].OutputValue[29] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue29_1"), var_list);
	SQLDataValueTOC1[2].OutputValue[29] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue29_2"), var_list);
	SQLDataValueTOC1[3].OutputValue[29] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue29_3"), var_list);
	SQLDataValueTOC1[4].OutputValue[29] = var_mapping(_T("SQLBindColumn_TOC1_OutputValue29_4"), var_list);
#endif
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	SQLDataValueTOC2A[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC2A_CrtCol_0"), var_list);
	SQLDataValueTOC2A[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC2A_CrtCol_1"), var_list);
	SQLDataValueTOC2A[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC2A_CrtCol_2"), var_list);
	SQLDataValueTOC2A[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC2A_CrtCol_3"), var_list);

	SQLDataValueTOC2B[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_0"), var_list);
	SQLDataValueTOC2B[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_1"), var_list);
	SQLDataValueTOC2B[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_2"), var_list);
	SQLDataValueTOC2B[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_3"), var_list);
	SQLDataValueTOC2B[4].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_4"), var_list);
	SQLDataValueTOC2B[5].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_5"), var_list);
	SQLDataValueTOC2B[6].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_6"), var_list);
	SQLDataValueTOC2B[7].CrtCol = var_mapping(_T("SQLBindColumn_TOC2B_CrtCol_7"), var_list);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	SQLDataValueTOC3A[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_0"), var_list);
	SQLDataValueTOC3A[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_1"), var_list);
	SQLDataValueTOC3A[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_2"), var_list);
	SQLDataValueTOC3A[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_3"), var_list);
	SQLDataValueTOC3A[4].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_4"), var_list);
	SQLDataValueTOC3A[5].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_5"), var_list);
	SQLDataValueTOC3A[6].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_6"), var_list);
	SQLDataValueTOC3A[7].CrtCol = var_mapping(_T("SQLBindColumn_TOC3A_CrtCol_7"), var_list);

	SQLDataValueTOC3B[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC3B_CrtCol_0"), var_list);
	SQLDataValueTOC3B[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC3B_CrtCol_1"), var_list);

	SQLDataValueTOC3C[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_0"), var_list);
	SQLDataValueTOC3C[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_1"), var_list);
	SQLDataValueTOC3C[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_2"), var_list);
	SQLDataValueTOC3C[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_3"), var_list);
	SQLDataValueTOC3C[4].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_4"), var_list);
	SQLDataValueTOC3C[5].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_5"), var_list);
	SQLDataValueTOC3C[6].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_6"), var_list);
	SQLDataValueTOC3C[7].CrtCol = var_mapping(_T("SQLBindColumn_TOC3C_CrtCol_7"), var_list);

	SQLDataValueTOC3D[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC3D_CrtCol_0"), var_list);
	SQLDataValueTOC3D[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC3D_CrtCol_1"), var_list);

	////////////////
	SQLDataValueTOC4A[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC4A_CrtCol_0"), var_list);
	SQLDataValueTOC4A[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC4A_CrtCol_1"), var_list);
	SQLDataValueTOC4A[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC4A_CrtCol_2"), var_list);
	SQLDataValueTOC4A[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC4A_CrtCol_3"), var_list);

	SQLDataValueTOC4B[0].CrtCol = var_mapping(_T("SQLBindColumn_TOC4B_CrtCol_0"), var_list);
	SQLDataValueTOC4B[1].CrtCol = var_mapping(_T("SQLBindColumn_TOC4B_CrtCol_1"), var_list);
	SQLDataValueTOC4B[2].CrtCol = var_mapping(_T("SQLBindColumn_TOC4B_CrtCol_2"), var_list);
	SQLDataValueTOC4B[3].CrtCol = var_mapping(_T("SQLBindColumn_TOC4B_CrtCol_3"), var_list);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	SQLDataValueTOCDef[0].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_0"), var_list);
	SQLDataValueTOCDef[0].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_0"), var_list);
	SQLDataValueTOCDef[0].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_0"), var_list);
	SQLDataValueTOCDef[0].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_0"), var_list);	
	SQLDataValueTOCDef[0].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_0"), var_list);	
	SQLDataValueTOCDef[0].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_0"), var_list);
	SQLDataValueTOCDef[0].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_0"), var_list);	
	SQLDataValueTOCDef[0].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_0"), var_list);

	SQLDataValueTOCDef[1].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_1"), var_list);
	SQLDataValueTOCDef[1].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_1"), var_list);
	SQLDataValueTOCDef[1].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_1"), var_list);
	SQLDataValueTOCDef[1].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_1"), var_list);	
	SQLDataValueTOCDef[1].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_1"), var_list);	
	SQLDataValueTOCDef[1].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_1"), var_list);
	SQLDataValueTOCDef[1].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_1"), var_list);	
	SQLDataValueTOCDef[1].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_1"), var_list);
	
	SQLDataValueTOCDef[2].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_2"), var_list);
	SQLDataValueTOCDef[2].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_2"), var_list);
	SQLDataValueTOCDef[2].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_2"), var_list);
	SQLDataValueTOCDef[2].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_2"), var_list);	
	SQLDataValueTOCDef[2].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_2"), var_list);	
	SQLDataValueTOCDef[2].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_2"), var_list);
	SQLDataValueTOCDef[2].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_2"), var_list);	
	SQLDataValueTOCDef[2].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_2"), var_list);
	
	SQLDataValueTOCDef[3].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_3"), var_list);
	SQLDataValueTOCDef[3].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_3"), var_list);
	SQLDataValueTOCDef[3].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_3"), var_list);
	SQLDataValueTOCDef[3].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_3"), var_list);	
	SQLDataValueTOCDef[3].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_3"), var_list);
	SQLDataValueTOCDef[3].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_3"), var_list);
	SQLDataValueTOCDef[3].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_3"), var_list);	
	SQLDataValueTOCDef[3].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_3"), var_list);

	SQLDataValueTOCDef[4].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_4"), var_list);
	SQLDataValueTOCDef[4].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_4"), var_list);
	SQLDataValueTOCDef[4].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_4"), var_list);
	SQLDataValueTOCDef[4].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_4"), var_list);	
	SQLDataValueTOCDef[4].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_4"), var_list);
	SQLDataValueTOCDef[4].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_4"), var_list);
	SQLDataValueTOCDef[4].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_4"), var_list);	
	SQLDataValueTOCDef[4].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_4"), var_list);

	SQLDataValueTOCDef[5].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_5"), var_list);
	SQLDataValueTOCDef[5].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_5"), var_list);
	SQLDataValueTOCDef[5].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_5"), var_list);
	SQLDataValueTOCDef[5].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_5"), var_list);	
	SQLDataValueTOCDef[5].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_5"), var_list);
	SQLDataValueTOCDef[5].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_5"), var_list);
	SQLDataValueTOCDef[5].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_5"), var_list);	
	SQLDataValueTOCDef[5].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_5"), var_list);

	SQLDataValueTOCDef[6].CrtCol = var_mapping(_T("SQLBindColumn_TOCDef_CrtCol_6"), var_list);
	SQLDataValueTOCDef[6].InsCol = var_mapping(_T("SQLBindColumn_TOCDef_InsCol_6"), var_list);
	SQLDataValueTOCDef[6].OutputCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputCharDef_6"), var_list);
	SQLDataValueTOCDef[6].OutputVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputVCharDef_6"), var_list);	
	SQLDataValueTOCDef[6].OutputLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputLVCharDef_6"), var_list);
	SQLDataValueTOCDef[6].OutputNCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNCharDef_6"), var_list);
	SQLDataValueTOCDef[6].OutputNVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNVCharDef_6"), var_list);	
	SQLDataValueTOCDef[6].OutputNLVCharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVCharDef_6"), var_list);

#ifdef UNICODE
	SQLDataValueTOCDef[0].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_0"), var_list);
	SQLDataValueTOCDef[1].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_1"), var_list);
	SQLDataValueTOCDef[2].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_2"), var_list);
	SQLDataValueTOCDef[3].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_3"), var_list);
	SQLDataValueTOCDef[4].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_4"), var_list);
	SQLDataValueTOCDef[5].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_5"), var_list);
	SQLDataValueTOCDef[6].OutputNLVUTF8CharDef = var_mapping(_T("SQLBindColumn_TOCDef_OutputNLVUTF8CharDef_6"), var_list);
#endif

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	SQLDataValueforLessBuf[0].CrtCol = var_mapping(_T("SQLBindColumn_DataValueLessBuf_CrtCol"), var_list);
	SQLDataValueforLessBuf[0].InsCol = var_mapping(_T("SQLBindColumn_DataValueLessBuf_InsCol"), var_list);
	SQLDataValueforLessBuf[0].OutputValue[0] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue0"), var_list);
	SQLDataValueforLessBuf[0].OutputValue[1] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue1"), var_list);
	SQLDataValueforLessBuf[0].OutputValue[2] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue2"), var_list);
	SQLDataValueforLessBuf[0].OutputValue[3] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue3"), var_list);
	SQLDataValueforLessBuf[0].OutputValue[4] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue4"), var_list);
	SQLDataValueforLessBuf[0].OutputValue[5] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue5"), var_list);

#ifdef UNICODE
	SQLDataValueforLessBuf[0].OutputValue[6] = var_mapping(_T("SQLBindColumn_DataValueLessBuf_OutputValue6"), var_list);
#endif

	///////////////
	CFloatToNumeric[0].CrtCol = var_mapping(_T("SQLBindColumn_CFloatToNumeric_0"), var_list);
	CFloatToNumeric[1].CrtCol = var_mapping(_T("SQLBindColumn_CFloatToNumeric_1"), var_list);
	CFloatToNumeric[2].CrtCol = var_mapping(_T("SQLBindColumn_CFloatToNumeric_2"), var_list);
	CFloatToNumeric[3].CrtCol = var_mapping(_T("SQLBindColumn_CFloatToNumeric_3"), var_list);

	CDoubleToNumeric[0].CrtCol = var_mapping(_T("SQLBindColumn_CDoubleToNumeric_0"), var_list);
	CDoubleToNumeric[1].CrtCol = var_mapping(_T("SQLBindColumn_CDoubleToNumeric_1"), var_list);
	CDoubleToNumeric[2].CrtCol = var_mapping(_T("SQLBindColumn_CDoubleToNumeric_2"), var_list);
	CDoubleToNumeric[3].CrtCol = var_mapping(_T("SQLBindColumn_CDoubleToNumeric_3"), var_list);

//===========================================================================================================

	//if(isUCS2) {
	//	k = sizeof(SQLDataValueforLessBuf)/sizeof(SQLDataValueforLessBuf[0]);
	//	for(i = 0; i < k; i++) {
	//		SQLDataValueforLessBuf[i].OutputLen = SQLDataValueforLessBuf[i].OutputLen * 2;
	//	}
	//	i = 0;
	//	k = 0;
	//}

//===========================================================================================================

	LogMsg(LINEBEFORE+SHORTTIMESTAMP,_T("Begin testing API =>SQLBindColumn.\n"));

	TEST_INIT;

	TESTCASE_BEGIN("Setup for SQLBindCol tests\n");
	if(!FullConnect(pTestInfo))
	{
		LogMsg(NONE,_T("Unable to connect\n"));
		TEST_FAILED;
		TEST_RETURN;
	}
	henv = pTestInfo->henv;
 	hdbc = pTestInfo->hdbc;
 	hstmt = (SQLHANDLE)pTestInfo->hstmt;
	returncode = SQLAllocStmt((SQLHANDLE)hdbc, &hstmt);	
	if(!CHECKRC(SQL_SUCCESS,returncode,"SQLAllocStmt"))
	{
		LogAllErrors(henv,hdbc,hstmt);
		TEST_FAILED;
		TEST_RETURN;
	}
	TESTCASE_END;  // end of setup

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC1[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab1,SQL_NTS);
		_stprintf(InsStr, _T("%s %s"), CrtTab1, SQLDataValueTOC1[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			k++;
			continue;
		}
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab1);
		_tcscat(InsStr,SQLDataValueTOC1[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			k++;
			continue;
		}
		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)SelTab1,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			k++;
			continue;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM1; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLTypeChar[i],SQLCTypeToChar(SQLDataValueTOC1[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			CCharOutput[i] = (TCHAR *)malloc(NAME_LEN*sizeof(TCHAR));
			returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC1[k].CType,CCharOutput[i],NAME_LEN,&OutputLen1[i]);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		TESTCASE_BEGIN("SQLBindCol: Positive test fetch from sql to SQL_C_TCHAR.\n");

		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC1[k].rcode)
		{
			for (i = 0; i < MAX_NUM1; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLTypeChar[i],SQLCTypeToChar(SQLDataValueTOC1[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				if (_tcsnicmp(SQLDataValueTOC1[k].OutputValue[i],CCharOutput[i],_tcslen(SQLDataValueTOC1[k].OutputValue[i])) == 0)
				{
					LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOC1[k].OutputValue[i],CCharOutput[i]);
				}	
				else
				{
					if (_tcscmp(_T("SQL_REAL"), TestSQLTypeChar[i]) == 0)
					{
						if (labs((long)(_tstof(SQLDataValueTOC1[k].OutputValue[i]) - _tstof(CCharOutput[i])) > 0.001))
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, at line: %d\n"),SQLDataValueTOC1[k].OutputValue[i],CCharOutput[i],__LINE__);
						}
					}
					else
					{
						TEST_FAILED;	
						LogMsg(ERRMSG,_T("(k:%d,i:%d) expect: %s and actual: %s are not matched, at line: %d\n"),k, i, SQLDataValueTOC1[k].OutputValue[i],CCharOutput[i],__LINE__);
					}
				}
				TESTCASE_END;
				free(CCharOutput[i]);
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab1,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC2A[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"), CrtTab2, SQLDataValueTOC2A[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC2A[k].InsCol);
		returncode  = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC2A[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC2A[k].CType)
			{
				case SQL_C_BIT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC2A[k].CType,&CBitOutput[i],0,&OutputLen2[i]);
					break;
				case SQL_C_UTINYINT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC2A[k].CType,&CUTinyintOutput[i],0,&OutputLen2[i]);
					break;
				default: ;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC2A[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC2A[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC2A[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC2A[k].CType)
				{
					case SQL_C_BIT:
						if (CBitOutput[i] == SQLDataValueTOC2A[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC2A[k].OutputValue[i],CBitOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC2A[k].OutputValue[i],CBitOutput[i],__LINE__);
						}
						break;
					case SQL_C_UTINYINT:
						if (CUTinyintOutput[i] == SQLDataValueTOC2A[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC2A[k].OutputValue[i],CUTinyintOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC2A[k].OutputValue[i],CUTinyintOutput[i],__LINE__);
						}
						break;
					default: ;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC2B[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"), CrtTab2,SQLDataValueTOC2B[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC2B[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC2B[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC2B[k].CType)
			{
				case SQL_C_STINYINT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC2B[k].CType,&CSTinyintOutput[i],0,&OutputLen2[i]);
					break;
				case SQL_C_TINYINT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC2B[k].CType,&CTinyintOutput[i],0,&OutputLen2[i]);
					break;
				default: ;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC2B[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC2B[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC2B[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC2B[k].CType)
				{
					case SQL_C_STINYINT:
						if (CSTinyintOutput[i] == SQLDataValueTOC2B[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC2B[k].OutputValue[i],CSTinyintOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %c are not matched, LINE = %d\n"),SQLDataValueTOC2B[k].OutputValue[i],CSTinyintOutput[i],__LINE__);
						}
						break;
					case SQL_C_TINYINT:
						if (CTinyintOutput[i] == SQLDataValueTOC2B[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC2B[k].OutputValue[i],CTinyintOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC2B[k].OutputValue[i],CTinyintOutput[i],__LINE__);
						}
						break;
					default: ;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	}	 

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC3A[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab2,SQLDataValueTOC3A[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC3A[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3A[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC3A[k].CType)
			{
				case SQL_C_SSHORT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC3A[k].CType,&CSShortOutput[i],0,&OutputLen2[i]);
					break;
				case SQL_C_SHORT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC3A[k].CType,&CShortOutput[i],0,&OutputLen2[i]);
					break;
				default: ;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC3A[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC3A[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3A[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC3A[k].CType)
				{
					case SQL_C_SSHORT:
						if (CSShortOutput[i] == SQLDataValueTOC3A[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC3A[k].OutputValue[i],CSShortOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC3A[k].OutputValue[i],CSShortOutput[i],__LINE__);
						}
						break;
					case SQL_C_SHORT:
						if (CShortOutput[i] == SQLDataValueTOC3A[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC3A[k].OutputValue[i],CShortOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC3A[k].OutputValue[i],CShortOutput[i],__LINE__);
						}
						break;
					default: ;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC3B[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab2,SQLDataValueTOC3B[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC3B[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3B[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC3B[k].CType)
			{
				case SQL_C_USHORT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC3B[k].CType,&CUShortOutput[i],0,&OutputLen2[i]);
					break;
				default: ;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC3B[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC3B[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3B[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC3B[k].CType)
				{
					case SQL_C_USHORT:
						if (CUShortOutput[i] == SQLDataValueTOC3B[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %u and actual: %u are matched\n"),SQLDataValueTOC3B[k].OutputValue[i],CUShortOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %u and actual: %u are not matched, LINE = %d\n"),SQLDataValueTOC3B[k].OutputValue[i],CUShortOutput[i],__LINE__);
						}
						break;
					default: 
                        break;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	}
		 
//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC3C[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab2,SQLDataValueTOC3C[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC3C[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3C[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC3C[k].CType)
			{
				case SQL_C_SLONG:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC3C[k].CType,&CSLongOutput[i],0,&OutputLen2[i]);
					break;
				case SQL_C_LONG:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC3C[k].CType,&CLongOutput[i],0,&OutputLen2[i]);
					break;
				default: 
                    break;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC3C[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC3C[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3C[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC3C[k].CType)
				{
					case SQL_C_SLONG:
						if (CSLongOutput[i] == SQLDataValueTOC3C[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %ld and actual: %ld are matched\n"),SQLDataValueTOC3C[k].OutputValue[i],CSLongOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %ld and actual: %ld are not matched, LINE = %d\n"),SQLDataValueTOC3C[k].OutputValue[i],CSLongOutput[i],__LINE__);
						}
						break;
					case SQL_C_LONG:
						if (CLongOutput[i] == SQLDataValueTOC3C[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %ld and actual: %ld are matched\n"),SQLDataValueTOC3C[k].OutputValue[i],CLongOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %ld and actual: %ld are not matched, LINE = %d\n"),SQLDataValueTOC3C[k].OutputValue[i],CLongOutput[i],__LINE__);
						}
						break;
					default: 
                        break;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC3D[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab2,SQLDataValueTOC3D[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC3D[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3D[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC3D[k].CType)
			{
				case SQL_C_ULONG:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC3D[k].CType,&CULongOutput[i],0,&OutputLen2[i]);
					break;
				default: 
                    break;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC3D[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC3D[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC3D[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC3D[k].CType)
				{
					case SQL_C_ULONG:
						if (CULongOutput[i] == SQLDataValueTOC3D[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %lu and actual: %lu are matched\n"),SQLDataValueTOC3D[k].OutputValue[i],CULongOutput[i]);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %lu and actual: %lu are not matched, LINE = %d\n"),SQLDataValueTOC3D[k].OutputValue[i],CULongOutput[i],__LINE__);
						}																				 
						break;
					default: 
                        break;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC4A[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab2,SQLDataValueTOC4A[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC4A[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC4A[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC4A[k].CType)
			{
				case SQL_C_FLOAT:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC4A[k].CType,&CFloatOutput[i],0,&OutputLen2[i]);
					break;
				default: 
                    break;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC4A[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC4A[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC4A[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC4A[k].CType)
				{
					case SQL_C_FLOAT:
						if (CFloatOutput[i] == SQLDataValueTOC4A[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %f and actual: %f are matched\n"),SQLDataValueTOC4A[k].OutputValue[i],CFloatOutput[i]);
						}	
						else
						{
							if (labs((long)(SQLDataValueTOC4A[k].OutputValue[i] - CFloatOutput[i])) > 0.001)
							{
								TEST_FAILED;	
								LogMsg(ERRMSG,_T("expect: %.5f and actual: %.5f are not matched at line %d\n"),SQLDataValueTOC4A[k].OutputValue[i],CFloatOutput[i],__LINE__);
							}
						}	
						break;
					default: 
                        break;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	} 

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC4B[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab2,SQLDataValueTOC4B[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab2);
		_tcscat(InsStr,SQLDataValueTOC4B[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab2,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM2; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC4B[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (SQLDataValueTOC4B[k].CType)
			{
				case SQL_C_DOUBLE:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC4B[k].CType,&CDoubleOutput[i],0,&OutputLen2[i]);
					break;
				default: 
                    break;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC4B[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if ((returncode == SQL_SUCCESS) || (returncode == SQL_SUCCESS_WITH_INFO))
		//if (returncode == SQLDataValueTOC4B[k].rcode)
		{
			for (i = 0; i < MAX_NUM2; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType[i],SQLCTypeToChar(SQLDataValueTOC4B[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (SQLDataValueTOC4B[k].CType)
				{
					case SQL_C_DOUBLE:
						if (CDoubleOutput[i] == SQLDataValueTOC4B[k].OutputValue[i])
						{
							//LogMsg(NONE,_T("expect: %e and actual: %e are matched\n"),SQLDataValueTOC4B[k].OutputValue[i],CDoubleOutput[i]);
						}	
						else																					
						{
							if (labs((long)(SQLDataValueTOC4B[k].OutputValue[i]-CDoubleOutput[i])) > 0.001)
							{
								TEST_FAILED;	
								LogMsg(ERRMSG,_T("expect: %.10f and actual: %.10f are not matched, LINE = %d\n"),SQLDataValueTOC4B[k].OutputValue[i],CDoubleOutput[i],__LINE__);
							}
						}
						break;
					default: 
                        break;
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab2,SQL_NTS);
		k++;
	} 

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC5[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab3,SQL_NTS);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)CrtTab3,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		_stprintf(InsStr,_T("%s %s"),InsTab3,SQLDataValueTOC5[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab3,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_DATETIME; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType1[i],SQLCTypeToChar(SQLDataValueTOC5[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC5[k].CType,&CDateOutput[i],0,&OutputLen2[i]);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC5[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC5[k].rcode)
		{
			for (i = 0; i < MAX_DATETIME; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType1[i],SQLCTypeToChar(SQLDataValueTOC5[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				if ((CDateOutput[i].year == SQLDataValueTOC5[k].yr[i]) && (CDateOutput[i].month == SQLDataValueTOC5[k].mn[i]) && (CDateOutput[i].day == SQLDataValueTOC5[k].dt[i]))
				{
					//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC5[k].yr[i],CDateOutput[i].year);
					//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC5[k].mn[i],CDateOutput[i].month);
					//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC5[k].dt[i],CDateOutput[i].day);
				}	
				else
				{
					TEST_FAILED;	
					LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC5[k].yr[i],CDateOutput[i].year,__LINE__);
					LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC5[k].mn[i],CDateOutput[i].month,__LINE__);
					LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC5[k].dt[i],CDateOutput[i].day,__LINE__);
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab3,SQL_NTS);
		k++;
	}
					 
//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC6[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab4,SQL_NTS);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)CrtTab4,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		_stprintf(InsStr,_T("%s %s"),InsTab4,SQLDataValueTOC6[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab4,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_DATETIME; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType2[i],SQLCTypeToChar(SQLDataValueTOC6[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC6[k].CType,&CTimeOutput[i],0,&OutputLen2[i]);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC6[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC6[k].rcode)
		{
			for (i = 0; i < MAX_DATETIME; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType2[i],SQLCTypeToChar(SQLDataValueTOC6[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				if ((CTimeOutput[i].hour == SQLDataValueTOC6[k].hr[i]) && (CTimeOutput[i].minute == SQLDataValueTOC6[k].mn[i]) && (CTimeOutput[i].second == SQLDataValueTOC6[k].sc[i]))
				{
					//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC6[k].hr[i],CTimeOutput[i].hour);
					//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC6[k].mn[i],CTimeOutput[i].minute);
					//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC6[k].sc[i],CTimeOutput[i].second);
				}	
				else
				{
					TEST_FAILED;	
					LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC6[k].hr[i],CTimeOutput[i].hour,__LINE__);
					LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC6[k].mn[i],CTimeOutput[i].minute,__LINE__);
					LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC6[k].sc[i],CTimeOutput[i].second,__LINE__);
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab4,SQL_NTS);
		k++;
	}	

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOC7[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab5,SQL_NTS);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)CrtTab5,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		_stprintf(InsStr,_T("%s %s"),InsTab5,SQLDataValueTOC7[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab5,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_TIMESTAMP; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLType3[i],SQLCTypeToChar(SQLDataValueTOC7[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOC7[k].CType,&CTimestampOutput[i],0,&OutputLen2[i]);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		_stprintf(Heading,_T("SQLBindCol: Positive test fetch from sql to %s.\n"),SQLCTypeToChar(SQLDataValueTOC7[k].CType,TempCType));
		TESTCASE_BEGINW(Heading);
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueTOC7[k].rcode)
		{
			for (i = 0; i < MAX_TIMESTAMP; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLType3[i],SQLCTypeToChar(SQLDataValueTOC7[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				if (i == 3)
				{
					if ((CTimestampOutput[i].hour == SQLDataValueTOC7[k].hr[i]) 
						&& (CTimestampOutput[i].minute == SQLDataValueTOC7[k].min[i]) 
						&& (CTimestampOutput[i].second == SQLDataValueTOC7[k].sc[i]))
					{
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].hr[i],CTimestampOutput[i].hour);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].min[i],CTimestampOutput[i].minute);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].sc[i],CTimestampOutput[i].second);
					}	
					else
					{
						TEST_FAILED;	
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].hr[i],CTimestampOutput[i].hour,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].min[i],CTimestampOutput[i].minute,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].sc[i],CTimestampOutput[i].second,__LINE__);
					}
				}
				else
				{
					if ((CTimestampOutput[i].year == SQLDataValueTOC7[k].yr[i]) 
						&& (CTimestampOutput[i].month == SQLDataValueTOC7[k].mon[i]) 
						&& (CTimestampOutput[i].day == SQLDataValueTOC7[k].dt[i]) 
						&& (CTimestampOutput[i].hour == SQLDataValueTOC7[k].hr[i]) 
						&& (CTimestampOutput[i].minute == SQLDataValueTOC7[k].min[i]) 
						&& (CTimestampOutput[i].second == SQLDataValueTOC7[k].sc[i]) 
						&& (CTimestampOutput[i].fraction == SQLDataValueTOC7[k].fr[i]))
					{
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].yr[i],CTimestampOutput[i].year);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].mon[i],CTimestampOutput[i].month);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].dt[i],CTimestampOutput[i].day);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].hr[i],CTimestampOutput[i].hour);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].min[i],CTimestampOutput[i].minute);
						//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOC7[k].sc[i],CTimestampOutput[i].second);
						//LogMsg(NONE,_T("expect: %lu and actual: %lu are matched\n"),SQLDataValueTOC7[k].fr[i],CTimestampOutput[i].fraction);
					}	
					else
					{
						TEST_FAILED;	
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].yr[i],CTimestampOutput[i].year,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].mon[i],CTimestampOutput[i].month,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].dt[i],CTimestampOutput[i].day,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].hr[i],CTimestampOutput[i].hour,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].min[i],CTimestampOutput[i].minute,__LINE__);
						LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOC7[k].sc[i],CTimestampOutput[i].second,__LINE__);
						LogMsg(ERRMSG,_T("expect: %lu and actual: %lu are not matched, LINE = %d\n"),SQLDataValueTOC7[k].fr[i],CTimestampOutput[i].fraction,__LINE__);
					}
				}
				TESTCASE_END;
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab5,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueTOCDef[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab7,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab7,SQLDataValueTOCDef[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab7);
		_tcscat(InsStr,SQLDataValueTOCDef[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab7,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		CharDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
		VCharDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
		DecDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
		NumDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
		LVCharDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
		BigintDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
 		ULintDefOutput = (char *)malloc(NAME_LEN*sizeof(char));
		CharDefOutputUCS2 = (wchar_t *)malloc(NAME_LEN*sizeof(wchar_t));
		VCharDefOutputUCS2 = (wchar_t *)malloc(NAME_LEN*sizeof(wchar_t));
		LVCharDefOutputUCS2 = (wchar_t *)malloc(NAME_LEN*sizeof(wchar_t));
		NLVUTF8CharDefOutput = (wchar_t *)malloc(NAME_LEN*sizeof(wchar_t));
		for (i = 0; i < MAX_NUM4; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestSQLTypeCharD[i],SQLCTypeToChar(SQLDataValueTOCDef[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			switch (i)
			{
				case 0:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,CharDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 1:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,VCharDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 2:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,DecDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 3:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,NumDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 4:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&SSintDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 5:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&USintDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 6:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&SLintDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 7:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,ULintDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 8:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&RealDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 9:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&FloatDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 10:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&DoubleDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 11:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&DateDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 12:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&TimeDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 13:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,&TimestampDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 14:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,LVCharDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 15:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,BigintDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				case 16:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,CharDefOutputUCS2,NAME_LEN,&DefOutputLen[i]);
					break;
				case 17:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,VCharDefOutputUCS2,NAME_LEN,&DefOutputLen[i]);
					break;
				case 18:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,LVCharDefOutputUCS2,NAME_LEN,&DefOutputLen[i]);
					break;
				case 19:
					returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueTOCDef[k].CType,NLVUTF8CharDefOutput,NAME_LEN,&DefOutputLen[i]);
					break;
				default: ;
			}
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		TESTCASE_BEGIN("SQLBindCol: Positive test fetch from sql to SQL_C_DEFAULT.\n");
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  


		if ((returncode == SQL_SUCCESS) || (returncode == SQL_SUCCESS_WITH_INFO))
		{
			for (i = 0; i < MAX_NUM4; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetched.\n"),i+1,TestSQLTypeCharD[i],SQLCTypeToChar(SQLDataValueTOCDef[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				switch (i)
				{
					case 0:
#ifdef UNICODE
						sizeconversion = mbstowcs(conversionbuffer, CharDefOutput, strlen(CharDefOutput)+1);
#else
						_tcscpy(conversionbuffer, CharDefOutput);
#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputCharDef,conversionbuffer) == 0 ||
							_tcsncmp(SQLDataValueTOCDef[k].OutputCharDef,conversionbuffer,_tcslen(SQLDataValueTOCDef[k].OutputCharDef)) == 0 ||
							_tcsncmp(SQLDataValueTOCDef[k].OutputCharDef,(TCHAR*)CharDefOutput,_tcslen(SQLDataValueTOCDef[k].OutputCharDef)) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputCharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputCharDef,conversionbuffer,__LINE__);
						}
						break;
					case 1:
#ifdef UNICODE
						sizeconversion = mbstowcs(conversionbuffer, VCharDefOutput, strlen(VCharDefOutput)+1);
#else
						_tcscpy(conversionbuffer, VCharDefOutput);
#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputVCharDef,conversionbuffer) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputVCharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputVCharDef,conversionbuffer,__LINE__);
						}
						break;
					case 2:
						if (strcmp(SQLDataValueTOCDef[k].OutputDecDef,DecDefOutput) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputDecDef,DecDefOutput);
						}	
						else
						{
							if (labs((long)(atof(DecDefOutput)-atof(SQLDataValueTOCDef[k].OutputDecDef))) > 0.001)
							{
								TEST_FAILED;	
								LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputDecDef,DecDefOutput,__LINE__);
							}
						}
						break;
					case 3:
						if (strcmp(SQLDataValueTOCDef[k].OutputNumDef,NumDefOutput) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputNumDef,NumDefOutput);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputNumDef,NumDefOutput,__LINE__);
						}
						break;
					case 4:
						if (SQLDataValueTOCDef[k].OutputSSintDef == SSintDefOutput)
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputSSintDef,SSintDefOutput);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputSSintDef,SSintDefOutput,__LINE__);
						}
						break;
					case 5:
						if (SQLDataValueTOCDef[k].OutputUSintDef == USintDefOutput)
						{
							//LogMsg(NONE,_T("expect: %u and actual: %u are matched\n"),SQLDataValueTOCDef[k].OutputUSintDef,USintDefOutput);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %u and actual: %u are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputUSintDef,USintDefOutput,__LINE__);
						}
						break;
					case 6:
						if (SQLDataValueTOCDef[k].OutputSLintDef == SLintDefOutput)
						{
							//LogMsg(NONE,_T("expect: %ld and actual: %ld are matched\n"),SQLDataValueTOCDef[k].OutputSLintDef,SLintDefOutput);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %ld and actual: %ld are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputSLintDef,SLintDefOutput,__LINE__);
						}
						break;
					case 7:
						if (strcmp(SQLDataValueTOCDef[k].OutputULintDef,ULintDefOutput) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputULintDef,ULintDefOutput);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputULintDef,ULintDefOutput,__LINE__);
						}
						break;
					case 8:
						if (SQLDataValueTOCDef[k].OutputRealDef == RealDefOutput)
						{
							//LogMsg(NONE,_T("expect: %f and actual: %f are matched\n"),SQLDataValueTOCDef[k].OutputRealDef,RealDefOutput);
						}	
						else
						{
							if (labs((long)(SQLDataValueTOCDef[k].OutputRealDef - RealDefOutput)) > 0.001)
							{
								TEST_FAILED;	
								LogMsg(ERRMSG,_T("expect: %f and actual: %f are not matched at line %d\n"),SQLDataValueTOCDef[k].OutputRealDef,RealDefOutput,__LINE__);
							}
						}
						break;
					case 9:
						if (SQLDataValueTOCDef[k].OutputFloatDef == FloatDefOutput)
						{
							//LogMsg(NONE,_T("expect: %e and actual: %e are matched\n"),SQLDataValueTOCDef[k].OutputFloatDef,FloatDefOutput);
						}	
						else
						{
							if (labs((long)(SQLDataValueTOCDef[k].OutputFloatDef-FloatDefOutput)) > 0.001)
							{
								TEST_FAILED;	
								LogMsg(ERRMSG,_T("expect: %e and actual: %e are not matched at line %d\n"),SQLDataValueTOCDef[k].OutputFloatDef,FloatDefOutput,__LINE__);
							}
						}
						break;
					case 10:
						if (SQLDataValueTOCDef[k].OutputDoubleDef == DoubleDefOutput)
						{
							//LogMsg(NONE,_T("expect: %e and actual: %e are matched\n"),SQLDataValueTOCDef[k].OutputDoubleDef,DoubleDefOutput);
						}	
						else
						{
							if (labs((long)(SQLDataValueTOCDef[k].OutputDoubleDef-DoubleDefOutput)) > 0.001)
							{
								TEST_FAILED;	
								LogMsg(ERRMSG,_T("expect: %e and actual: %e are not matched at line %d\n"),SQLDataValueTOCDef[k].OutputDoubleDef,DoubleDefOutput,__LINE__);
							}
						}
						break;
					case 11:
#ifndef _WM
						if ((SQLDataValueTOCDef[k].OutputDateDef.year == DateDefOutput.year) && (SQLDataValueTOCDef[k].OutputDateDef.month == DateDefOutput.month) && (SQLDataValueTOCDef[k].OutputDateDef.day == DateDefOutput.day))
#else
                        if (_tcscmp(SQLDataValueTOCDef[k].OutputDateDef,DateDefOutput)==0)
#endif
                        {
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputDateDef.year,DateDefOutput.year);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputDateDef.month,DateDefOutput.month);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputDateDef.day,DateDefOutput.day);
						}	
						else
						{
							TEST_FAILED;
#ifndef _WM
							LogMsg(ERRMSG,_T("k=%d: expect: %d and actual: %d are not matched, LINE = %d\n"),k,SQLDataValueTOCDef[k].OutputDateDef.year,DateDefOutput.year,__LINE__);
							LogMsg(ERRMSG,_T("k=%d: expect: %d and actual: %d are not matched, LINE = %d\n"),k,SQLDataValueTOCDef[k].OutputDateDef.month,DateDefOutput.month,__LINE__);
							LogMsg(ERRMSG,_T("k=%d: expect: %d and actual: %d are not matched, LINE = %d\n"),k,SQLDataValueTOCDef[k].OutputDateDef.day,DateDefOutput.day,__LINE__);
#else
                            LogMsg(ERRMSG,_T("k=%d: expect: %s and actual: %s are not matched, LINE = %d\n"),k,SQLDataValueTOCDef[k].OutputDateDef,DateDefOutput,__LINE__);
#endif
                        }
						break;
					case 12:
						if ((SQLDataValueTOCDef[k].OutputTimeDef.hour == TimeDefOutput.hour) && (SQLDataValueTOCDef[k].OutputTimeDef.minute == TimeDefOutput.minute) && (SQLDataValueTOCDef[k].OutputTimeDef.second == TimeDefOutput.second))
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimeDef.hour,TimeDefOutput.hour);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimeDef.minute,TimeDefOutput.minute);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimeDef.second,TimeDefOutput.second);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimeDef.hour,TimeDefOutput.hour,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimeDef.minute,TimeDefOutput.minute,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimeDef.second,TimeDefOutput.second,__LINE__);
						}
						break;
					case 13:
						if ((SQLDataValueTOCDef[k].OutputTimestampDef.year == TimestampDefOutput.year) && (SQLDataValueTOCDef[k].OutputTimestampDef.month == TimestampDefOutput.month) && (SQLDataValueTOCDef[k].OutputTimestampDef.day == TimestampDefOutput.day) && (SQLDataValueTOCDef[k].OutputTimestampDef.hour == TimestampDefOutput.hour) && (SQLDataValueTOCDef[k].OutputTimestampDef.minute == TimestampDefOutput.minute) && (SQLDataValueTOCDef[k].OutputTimestampDef.second == TimestampDefOutput.second) && (SQLDataValueTOCDef[k].OutputTimestampDef.fraction == TimestampDefOutput.fraction))
						{
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.year,TimestampDefOutput.year);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.month,TimestampDefOutput.month);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.day,TimestampDefOutput.day);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.hour,TimestampDefOutput.hour);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.minute,TimestampDefOutput.minute);
							//LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.second,TimestampDefOutput.second);
							//LogMsg(NONE,_T("expect: %lu and actual: %lu are matched\n"),SQLDataValueTOCDef[k].OutputTimestampDef.fraction,TimestampDefOutput.fraction);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %l and actual: %l are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.year,TimestampDefOutput.year,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.month,TimestampDefOutput.month,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.day,TimestampDefOutput.day,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.hour,TimestampDefOutput.hour,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.minute,TimestampDefOutput.minute,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.second,TimestampDefOutput.second,__LINE__);
							LogMsg(ERRMSG,_T("expect: %lu and actual: %lu are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputTimestampDef.fraction,TimestampDefOutput.fraction,__LINE__);
						}
						break;
					case 14:
#ifdef UNICODE
						sizeconversion = mbstowcs(conversionbuffer, LVCharDefOutput, strlen(LVCharDefOutput)+1);
#else
						_tcscpy(conversionbuffer, LVCharDefOutput);
#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputLVCharDef,conversionbuffer) == 0 || 
							_tcsncmp(SQLDataValueTOCDef[k].OutputLVCharDef,conversionbuffer,_tcslen(SQLDataValueTOCDef[k].OutputLVCharDef)) == 0 ||
							_tcsncmp(SQLDataValueTOCDef[k].OutputLVCharDef,(TCHAR*)LVCharDefOutput,_tcslen(SQLDataValueTOCDef[k].OutputLVCharDef)) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputLVCharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputLVCharDef,conversionbuffer,__LINE__);
						}
						break;
					case 15:
						if (strcmp(SQLDataValueTOCDef[k].OutputBigintDef,BigintDefOutput) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputBigintDef,BigintDefOutput);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputBigintDef,BigintDefOutput,__LINE__);
						}
						break;
					case 16:
//#ifdef UNICODE
						_tcscpy(conversionbuffer, (TCHAR*)CharDefOutputUCS2);
//#else
//						sizeconversion = wcstombs(conversionbuffer, (wchar_t *)CharDefOutputUCS2, sizeof(conversionbuffer));
//#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputNCharDef,conversionbuffer) == 0 ||
							_tcsncmp(SQLDataValueTOCDef[k].OutputNCharDef,conversionbuffer,_tcslen(SQLDataValueTOCDef[k].OutputNCharDef)) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputNCharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputNCharDef,conversionbuffer,__LINE__);
						}
						break;
					case 17:
//#ifdef UNICODE
						_tcscpy(conversionbuffer, (TCHAR*)VCharDefOutputUCS2);
//#else
//						sizeconversion = wcstombs(conversionbuffer, (wchar_t *)VCharDefOutputUCS2, sizeof(conversionbuffer));
//#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputNVCharDef,conversionbuffer) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputNVCharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputNVCharDef,conversionbuffer,__LINE__);
						}
						break;
					case 18:
//#ifdef UNICODE
						_tcscpy(conversionbuffer, (TCHAR*)LVCharDefOutputUCS2);
//#else
//						sizeconversion = wcstombs(conversionbuffer, (wchar_t *)LVCharDefOutputUCS2, sizeof(conversionbuffer));
//#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputNLVCharDef,conversionbuffer) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputNLVCharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputNLVCharDef,conversionbuffer,__LINE__);
						}
						break;
#ifdef UNICODE
					case 19:
//#ifdef UNICODE
						//_tcscpy(conversionbuffer, (TCHAR*)NLVUTF8CharDefOutput);
						sizeconversion = mbstowcs(conversionbuffer, (const char*)NLVUTF8CharDefOutput, _tcslen(NLVUTF8CharDefOutput)+1);
//#else
						//sizeconversion = wcstombs(conversionbuffer, (wchar_t *)LVCharDefOutputUCS2, sizeof(conversionbuffer));
//#endif
						if (_tcscmp(SQLDataValueTOCDef[k].OutputNLVUTF8CharDef,conversionbuffer) == 0)
						{
							//LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),SQLDataValueTOCDef[k].OutputNLVUTF8CharDef,conversionbuffer);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueTOCDef[k].OutputNLVUTF8CharDef,conversionbuffer,__LINE__);
						}
						break;
#endif
					default:
						LogMsg(ERRMSG,_T("WHY AM I HERE???, LINE = %d\n"),__LINE__);
                        break;

				}
				TESTCASE_END;
			}  
		}
		free(CharDefOutput);
		free(VCharDefOutput);
		free(DecDefOutput);
		free(NumDefOutput);
		free(LVCharDefOutput);
		free(BigintDefOutput);
		free(ULintDefOutput);
		free(CharDefOutputUCS2);
		free(VCharDefOutputUCS2);
		free(LVCharDefOutputUCS2);
#ifdef UNICODE
		free(NLVUTF8CharDefOutput);
#endif
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab7,SQL_NTS);
		k++;
	}

//=============================================================================================================

	k = 0;
	while (SQLDataValueforLessBuf[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: create insert and select from table \n"));
		TESTCASE_BEGINW(Heading);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab6,SQL_NTS);
		_stprintf(InsStr,_T("%s %s"),CrtTab6,SQLDataValueforLessBuf[k].CrtCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect Create"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		_tcscpy(InsStr,_T(""));
		_tcscat(InsStr,InsTab6);
		_tcscat(InsStr,SQLDataValueforLessBuf[k].InsCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect Insert"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)SelTab6,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect Select"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
			TEST_RETURN;
		}
		TESTCASE_END;  

		for (i = 0; i < MAX_NUM3; i++)
		{  
			_stprintf(Heading,_T("SQLBindCol: Positive test #%d for converting %s to %s before fetch.\n"),i+1,TestforLessBuf[i],SQLCTypeToChar(SQLDataValueforLessBuf[k].CType,TempCType));
			TESTCASE_BEGINW(Heading);
			COutputlessBuf[i] = (TCHAR *)malloc(NAME_LEN);
			returncode = SQLBindCol(hstmt,(SWORD)(i+1),SQLDataValueforLessBuf[k].CType,COutputlessBuf[i],SQLDataValueforLessBuf[k].OutputLen,&OutputLenlessbuf[i]);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			TESTCASE_END;  
		}  
			
		TESTCASE_BEGIN("SQLBindCol: Positive test fetch from sql to SQL_C_TCHAR.\n");
		returncode = SQLFetch(hstmt);
		if(!CHECKRC(SQL_SUCCESS_WITH_INFO,returncode,"SQLFetch"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		TESTCASE_END;  

		if (returncode == SQLDataValueforLessBuf[k].rcode)
		{
			for (i = 0; i < MAX_NUM3; i++)
			{  
				_stprintf(Heading,_T("SQLBindCol: Positive test #%d for comparing values %s to %s after fetch.\n"),i+1,TestforLessBuf[i],SQLCTypeToChar(SQLDataValueforLessBuf[k].CType,TempCType));
				TESTCASE_BEGINW(Heading);
				if ((_tcsnicmp(SQLDataValueforLessBuf[k].OutputValue[i],COutputlessBuf[i],_tcslen(COutputlessBuf[i])) == 0) &&
					/* (OutputLenlessbuf[i] == _tcslen(SQLDataValueforLessBuf[k].OutputValue[i])*sizeof(TCHAR)) && */
					(SQLDataValueforLessBuf[k].OutputLen == ((_tcslen(COutputlessBuf[i])+1)*sizeof(TCHAR))))
				{
					LogMsg(NONE,_T("expect: %s and actual: %s are matched, LINE = %d\n"),SQLDataValueforLessBuf[k].OutputValue[i],COutputlessBuf[i],__LINE__);
					LogMsg(NONE,_T("expect length of the data available to return: %d and actual length of the data available to return: %d are matched, LINE = %d\n"),
						_tcslen(SQLDataValueforLessBuf[k].OutputValue[i])*sizeof(TCHAR), OutputLenlessbuf[i],__LINE__);
					LogMsg(NONE,_T("expect length of the data returned: %d and actual length of the data returned: %d are matched, LINE = %d\n"),
						SQLDataValueforLessBuf[k].OutputLen, (_tcslen(COutputlessBuf[i])+1)*sizeof(TCHAR),__LINE__);
				}	
				else
				{
					TEST_FAILED;	
					LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, LINE = %d\n"),SQLDataValueforLessBuf[k].OutputValue[i],COutputlessBuf[i],__LINE__);
					LogMsg(ERRMSG,_T("expect length of the data available to return: %d and actual length of the data available to return: %d are not matched, LINE = %d\n"),
						_tcslen(SQLDataValueforLessBuf[k].OutputValue[i])*sizeof(TCHAR), OutputLenlessbuf[i],__LINE__);
					LogMsg(ERRMSG,_T("expect length of the data returned: %d and actual length of the data returned: %d are not matched, LINE = %d\n"),
						SQLDataValueforLessBuf[k].OutputLen, (_tcslen(COutputlessBuf[i])+1)*sizeof(TCHAR),__LINE__);
				}
				TESTCASE_END;
				free(COutputlessBuf[i]);
			}  
		}
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		SQLExecDirect(hstmt, (SQLTCHAR*)DrpTab6,SQL_NTS);
		k++;
	}

//=============================================================================================================

	//SQLExecDirect(hstmt,_T("drop table diffadd"),SQL_NTS);
	SQLExecDirect(hstmt,(SQLTCHAR*)_T("drop table diffadd"),SQL_NTS);
	returncode = SQLExecDirect(hstmt, (SQLTCHAR*)_T("create table diffadd (C int) no partition"),SQL_NTS);
	if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
	{
		LogAllErrors(henv,hdbc,hstmt);
		TEST_FAILED;
		TEST_RETURN;
	}

	returncode = SQLExecDirect(hstmt, (SQLTCHAR*)_T("insert into diffadd values (1)"),SQL_NTS);
	if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
	{
		LogAllErrors(henv,hdbc,hstmt);
		TEST_FAILED;
		TEST_RETURN;
	}

	k = 0;
	while (TimeStampFunction[k].CType != 999)
	{
		_stprintf(Heading,_T("SQLBindCol: Test #%d: Testing TimeStampAdd and TimeStampDiff fuctions\n"), k);
		TESTCASE_BEGINW(Heading);
		_stprintf(InsStr,_T("select %s from diffadd"),TimeStampFunction[k].selCol);
		returncode = SQLExecDirect(hstmt, (SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
		}

		switch (TimeStampFunction[k].CType)
		{
			case SQL_C_TIMESTAMP:
				returncode = SQLBindCol(hstmt,(SWORD)(1),TimeStampFunction[k].CType,&outputTimeStamp,0,&outputSize);
				break;
			case SQL_C_TIME:
				returncode = SQLBindCol(hstmt,(SWORD)(1),TimeStampFunction[k].CType,&outputTime,0,&outputSize);
				break;
			case SQL_C_DATE:
				returncode = SQLBindCol(hstmt,(SWORD)(1),TimeStampFunction[k].CType,&outputDate,0,&outputSize);
				break;
			case SQL_C_TCHAR:
				returncode = SQLBindCol(hstmt,(SWORD)(1),TimeStampFunction[k].CType,outputChar,300,&outputSize);
				break;
			case SQL_C_LONG:
				returncode = SQLBindCol(hstmt,(SWORD)(1),TimeStampFunction[k].CType,&outputInt,0,&outputSize);
				break;
			default:
				break;
		}

		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
			
		returncode = SQLFetch(hstmt);
		if (returncode == TimeStampFunction[k].rcode)
		{
			if (returncode != SQL_ERROR) {
				switch (TimeStampFunction[k].CType)
				{
					case SQL_C_TIMESTAMP:
						if ((TimeStampFunction[k].expTimeStamp.year == outputTimeStamp.year) 
							&& (TimeStampFunction[k].expTimeStamp.month == outputTimeStamp.month) 
							&& (TimeStampFunction[k].expTimeStamp.day == outputTimeStamp.day)
							&& (TimeStampFunction[k].expTimeStamp.hour == outputTimeStamp.hour) 
							&& (TimeStampFunction[k].expTimeStamp.minute == outputTimeStamp.minute) 
							&& (TimeStampFunction[k].expTimeStamp.second == outputTimeStamp.second) 
							&& (TimeStampFunction[k].expTimeStamp.fraction == outputTimeStamp.fraction))
						{
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.year,outputTimeStamp.year);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.month,outputTimeStamp.month);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.day,outputTimeStamp.day);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.hour,outputTimeStamp.hour);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.minute,outputTimeStamp.minute);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.second,outputTimeStamp.second);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTimeStamp.fraction,outputTimeStamp.fraction);
						}
						else {
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.year,outputTimeStamp.year,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.month,outputTimeStamp.month,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.day,outputTimeStamp.day,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.hour,outputTimeStamp.hour,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.minute,outputTimeStamp.minute,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.second,outputTimeStamp.second,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTimeStamp.fraction,outputTimeStamp.fraction,__LINE__);
						}
						break;
					case SQL_C_TIME:
						if ((TimeStampFunction[k].expTime.hour == outputTime.hour) 
							&& (TimeStampFunction[k].expTime.minute == outputTime.minute) 
							&& (TimeStampFunction[k].expTime.second == outputTime.second))
						{
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTime.hour,outputTime.hour);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTime.minute,outputTime.minute);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expTime.second,outputTime.second);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTime.hour,outputTime.hour,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTime.minute,outputTime.minute,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expTime.second,outputTime.second,__LINE__);
						}
						break;
					case SQL_C_DATE:
						if ((TimeStampFunction[k].expDate.year == outputDate.year) 
							&& (TimeStampFunction[k].expDate.month == outputDate.month) 
							&& (TimeStampFunction[k].expDate.day == outputDate.day))
						{
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expDate.year,outputDate.year);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expDate.month,outputDate.month);
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expDate.day,outputDate.day);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expDate.year,outputDate.year,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expDate.month,outputDate.month,__LINE__);
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, LINE = %d\n"),TimeStampFunction[k].expDate.day,outputDate.day,__LINE__);
						}
						break;
					case SQL_C_TCHAR:
						if (_tcscmp(TimeStampFunction[k].expChar,outputChar) == 0)
						{
							LogMsg(NONE,_T("expect: %s and actual: %s are matched\n"),TimeStampFunction[k].expChar,outputChar);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %s and actual: %s are not matched, at line: %d\n"),TimeStampFunction[k].expChar,outputChar,__LINE__);
						}
						break;
					case SQL_C_LONG:
						if (TimeStampFunction[k].expInt == outputInt)
						{
							LogMsg(NONE,_T("expect: %d and actual: %d are matched\n"),TimeStampFunction[k].expInt,outputInt);
						}	
						else
						{
							TEST_FAILED;	
							LogMsg(ERRMSG,_T("expect: %d and actual: %d are not matched, at line: %d\n"),TimeStampFunction[k].expInt,outputInt,__LINE__);
						}
						break;
					break;
						break;
				}
			}
			else {
				LogMsg(NONE,_T("expect returncode: %d and actual returncode: %d are matched\n"),TimeStampFunction[k].rcode,returncode);
			}
		}
		else {
			TEST_FAILED;	
			LogMsg(ERRMSG,_T("expect returncode: %d and actual returncode: %d are not matched, at line: %d\n"),TimeStampFunction[k].rcode,returncode,__LINE__);
		}
		
		TESTCASE_END;

		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_UNBIND);
		k++;
	}
	SQLExecDirect(hstmt, (SQLTCHAR*)_T("drop table diffadd"),SQL_NTS);

//=================================================================================================================
// Convert SQL_C_FLOAT to SQL_NUMERIC
#if 0
    i = 0;
	while (CFloatToNumeric[i].PassFail != 999)
	{
		TESTCASE_BEGIN("SQLBindColumn tests to bind from SQL_C_FLOAT to SQL_NUMERIC.\n");
		SQLExecDirect(hstmt,(SQLTCHAR*) DrpTab8,SQL_NTS);
        _stprintf(InsStr, _T("%s %s"), CrtTab8, CFloatToNumeric[i].CrtCol);
		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
		}

		_stprintf(InsStr, _T("%s (%s)"), InsTab8, CFloatToNumeric[i].InputValue);
		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecdirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
		}

		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)SelTab8,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		else
		{
			for(j = 0; j < MAX_NUM5; j++) 
			{
				returncode = SQLBindCol(hstmt,(SWORD)(j+1),SQL_C_FLOAT,&(FloatOutValue[j]), 0,&(outSize[j]));
				if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindColumn"))
				{
					TEST_FAILED;
					LogAllErrors(henv,hdbc,hstmt);
				}
			}

			returncode = SQLFetch(hstmt);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			else
			{
				for (j = 0; j < MAX_NUM5; j++)
				{
					LogMsg(NONE,_T("SQLBindColumn test:checking data for column c%d\n"),j+1);
					if (fabsf(CFloatToNumeric[i].ExpectedFloatValue[j]-FloatOutValue[j]) < 0.000001)
					{
						LogMsg(NONE,_T("expect: %lf and actual: %lf are matched\n"),CFloatToNumeric[i].ExpectedFloatValue[j],FloatOutValue[j]);
					}	
					else
					{
						TEST_FAILED;	
						LogMsg(ERRMSG,_T("expect: %lf and actual: %lf are not matched at line %d\n"),CFloatToNumeric[i].ExpectedFloatValue[j],FloatOutValue[j],__LINE__);
					}
				} // end for loop
			}
		}
		TESTCASE_END;
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_RESET_PARAMS);
		SQLExecDirect(hstmt,(SQLTCHAR*) DrpTab8,SQL_NTS);
		i++;
	}

//=================================================================================================================
// Convert SQL_C_DOUBLE to SQL_NUMERIC

    i = 0;
	while (CDoubleToNumeric[i].PassFail != 999)
	{
		TESTCASE_BEGIN("SQLBindColumn tests to bind from SQL_C_DOUBLE to SQL_NUMERIC.\n");
		SQLExecDirect(hstmt,(SQLTCHAR*) DrpTab8,SQL_NTS);
        _stprintf(InsStr, _T("%s %s"), CrtTab8, CDoubleToNumeric[i].CrtCol);
		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
		}

		_stprintf(InsStr, _T("%s (%s)"), InsTab8, CDoubleToNumeric[i].InputValue);
		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)InsStr,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecdirect"))
		{
			LogAllErrors(henv,hdbc,hstmt);
			TEST_FAILED;
		}

		returncode = SQLExecDirect(hstmt,(SQLTCHAR*)SelTab8,SQL_NTS);
		if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
		{
			TEST_FAILED;
			LogAllErrors(henv,hdbc,hstmt);
		}
		else
		{
			for(j = 0; j < MAX_NUM5; j++) 
			{
				returncode = SQLBindCol(hstmt,(SWORD)(j+1),SQL_C_DOUBLE,&(DoubleOutValue[j]),0,&(outSize[j]));
				if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindColumn"))
				{
					TEST_FAILED;
					LogAllErrors(henv,hdbc,hstmt);
				}
			}

			returncode = SQLFetch(hstmt);
			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLFetch"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
			else
			{
				for (j = 0; j < MAX_NUM5; j++)
				{
					LogMsg(NONE,_T("SQLBindColumn test:checking data for column c%d\n"),j+1);
					if (fabs(CDoubleToNumeric[i].ExpectedDoubleValue[j]-DoubleOutValue[j]) < 0.000001)
					{
						LogMsg(NONE,_T("expect: %lf and actual: %lf are matched\n"),CDoubleToNumeric[i].ExpectedDoubleValue[j],DoubleOutValue[j]);
					}	
					else
					{
						TEST_FAILED;	
						LogMsg(ERRMSG,_T("expect: %lf and actual: %lf are not matched at line %d\n"),CDoubleToNumeric[i].ExpectedDoubleValue[j],DoubleOutValue[j],__LINE__);
					}
				} // end for loop
			}
		}
		TESTCASE_END;
		SQLFreeStmt(hstmt,SQL_CLOSE);
		SQLFreeStmt(hstmt,SQL_RESET_PARAMS);
		SQLExecDirect(hstmt,(SQLTCHAR*) DrpTab8,SQL_NTS);
		i++;
	}
#endif
	//=================================================================================================================
	// Section #10: negative test to convert SQL_NUMERIC (Bignum) to all CTypes 
	TESTCASE_BEGIN("Setup for SQLBindCol negative tests to convert SQL_NUMERIC (Bignum) to all CTypes\n");
	SQLExecDirect(hstmt,(SQLTCHAR*) DrpTab10,SQL_NTS);
	returncode = SQLExecDirect(hstmt,(SQLTCHAR*)CrtTab10,SQL_NTS);
	if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
	{
		LogAllErrors(henv,hdbc,hstmt);
		TEST_FAILED;
		TEST_RETURN;
	}

	returncode = SQLExecDirect(hstmt,(SQLTCHAR*)InsTab10,SQL_NTS);
	if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecDirect"))
	{
		LogAllErrors(henv,hdbc,hstmt);
		TEST_FAILED;
		TEST_RETURN;
	}

	for (loop_bindparam = 0; loop_bindparam < BINDPARAM_FOR_PREPEXEC_EXECDIRECT; loop_bindparam++)
	{
		i = 0;
		while (CTypeAll[i] != 999)
		{
			LogMsg(LINEBEFORE,_T("Test id = %d\n"), i+1);
			if (loop_bindparam == BINDPARAM_PREPARE_EXECUTE)
			{
				LogMsg(LINEAFTER,_T("SQLBindCol negative tests for prepare to convert SQL_NUMERIC (Bignum) to all CTypes\n"));
				returncode = SQLPrepare(hstmt,(SQLTCHAR*)SelTab10,SQL_NTS);
 				if(!CHECKRC(SQL_SUCCESS,returncode,"SQLPrepare"))
				{
					LogAllErrors(henv,hdbc,hstmt);
					TEST_FAILED;
					TEST_RETURN;
				}
			}
			if (loop_bindparam == BINDPARAM_EXECDIRECT)
			{
				LogMsg(LINEAFTER,_T("SQLBindCol negative tests for ExecDirect to convert SQL_NUMERIC (Bignum) to all CTypes\n"));
				returncode = SQLExecDirect(hstmt,(SQLTCHAR*)SelTab10,SQL_NTS);
				if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecute"))
				{
					TEST_FAILED;
					LogAllErrors(henv,hdbc,hstmt);
				}
			}

			LogMsg(NONE,_T("SQLBindCol from to convert from SQL_NUMERIC (Bignum) to %s\n"), SQLCTypeToChar(CTypeAll[i],InsStr));
			switch (CTypeAll[i]) {
				case SQL_C_BINARY:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],BinaryVal, NAME_LEN,&outputSize);
					break;
				case SQL_C_BIT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&BitVal, 0,&outputSize);
					break;
				case SQL_C_SHORT:
				case SQL_C_SSHORT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&ShortVal, 0,&outputSize);
					break;
				case SQL_C_USHORT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&UShortVal, 0,&outputSize);
					break;
				case SQL_C_LONG:
				case SQL_C_SLONG:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&LongVal, 0,&outputSize);
					break;
				case SQL_C_ULONG:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&ULongVal, 0,&outputSize);
					break;
				case SQL_C_TINYINT:
				case SQL_C_STINYINT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&TinyIntVal, 0,&outputSize);
					break;
				case SQL_C_UTINYINT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&UTinyIntVal, 0,&outputSize);
					break;
				case SQL_C_SBIGINT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&BigIntVal, 0,&outputSize);
					break;
				case SQL_C_UBIGINT:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&UBigIntVal, 0,&outputSize);
					break;
				case SQL_C_NUMERIC:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&NumericVal, 0,&outputSize);
					break;
				case SQL_C_INTERVAL_DAY:
				case SQL_C_INTERVAL_DAY_TO_HOUR:
				case SQL_C_INTERVAL_DAY_TO_MINUTE:
				case SQL_C_INTERVAL_DAY_TO_SECOND:
				case SQL_C_INTERVAL_HOUR:
				case SQL_C_INTERVAL_HOUR_TO_MINUTE:
				case SQL_C_INTERVAL_HOUR_TO_SECOND:
				case SQL_C_INTERVAL_MINUTE:
				case SQL_C_INTERVAL_MINUTE_TO_SECOND:
				case SQL_C_INTERVAL_SECOND:
				case SQL_C_INTERVAL_MONTH:
				case SQL_C_INTERVAL_YEAR:
				case SQL_C_INTERVAL_YEAR_TO_MONTH:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&IntevalVal, 0,&outputSize);
					break;
				case SQL_C_DATE:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&outputDate, 0,&outputSize);
					break;
				case SQL_C_TIME:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&outputTime, 0,&outputSize);
					break;
				case SQL_C_TIMESTAMP:
					returncode = SQLBindCol(hstmt,(SWORD)(1),CTypeAll[i],&outputTimeStamp, 0,&outputSize);
					break;
				default:
					break;
			}

			if(!CHECKRC(SQL_SUCCESS,returncode,"SQLBindCol"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}
		
			if (loop_bindparam == BINDPARAM_PREPARE_EXECUTE)
			{
				LogMsg(LINEAFTER,_T("SQLBindCol negative tests for Execute to convert SQL_NUMERIC (Bignum) to all CTypes\n"));
				returncode = SQLExecute(hstmt); 
				if(!CHECKRC(SQL_SUCCESS,returncode,"SQLExecute"))
				{
					TEST_FAILED;
					LogAllErrors(henv,hdbc,hstmt);
				}
			}

			LogMsg(LINEAFTER,_T("SQLBindCol negative tests for Fetch to convert SQL_NUMERIC (Bignum) to all CTypes\n"));
			returncode = SQLFetch(hstmt);
			if(!CHECKRC(SQL_ERROR,returncode,"SQLFetch"))
			{
				TEST_FAILED;
				LogAllErrors(henv,hdbc,hstmt);
			}

			//LogMsg(NONE,_T("RETCODE=%d\n"), returncode);
			//LogAllErrors(henv,hdbc,hstmt);
			i++;
			
			SQLFreeStmt(hstmt,SQL_CLOSE);
			SQLFreeStmt(hstmt,SQL_RESET_PARAMS);
		}
	}
	TESTCASE_END;
	SQLFreeStmt(hstmt,SQL_CLOSE);
	SQLFreeStmt(hstmt,SQL_RESET_PARAMS);
	SQLExecDirect(hstmt,(SQLTCHAR*) DrpTab10,SQL_NTS);

//=============================================================================================================
	
	FullDisconnect(pTestInfo);
	LogMsg(SHORTTIMESTAMP+LINEAFTER,_T("End testing API => SQLBindColumn.\n"));
	free_list(var_list);
	TEST_RETURN;

}
